"Fast Api"

		'-Api y FastApi'
		-FastApi es una libreria de python que nos permite construir API, basicamemte las apicaciones que nos permiten interactuar con datos y que 
		 facilitan el intercambio de datos entre distintos tipos de aplicaciones, aplicaciones de escritorio, aplicaciones web, aplicacion movil.
		
		-El cliente (aplicaciones de escritorio, aplicaciones web, aplicacion movil) a traves de la nube, a traves de algun recurso que esta 
		 ospedado en algun lugar, puede enviar y solicitar datos, esa api se comunica con uno o mas 
		 repositorios (bases de datos relacionales o no, xml, json)

		-Las APi podrian considerarce como una abstraccion, Exponen un conjunto de funiones que pueden ser conusumidas llamadas de diferentes 
		 tipos de clientes, y la API permite que multiples aplicaciones que soliciten, envien datos a guardar y la interfaz es la misma.



		-Lo que vamos a hacer como tares es crear un repositorio en git, luego de eso vamos a crear un ambiente virtual
		
		-Verificamos primero la vercion de python que tenemos en nuestro ordenador, luego escribimos en comando 
			' python -m venv venv '

		-Luego de crear el ambiente virtual devemos activarlo lo podemos hacer llendo a la flechita al lado del mas utilizando el comando
		 promp por defecto , tambine lo podemos hacer con powershell y tambine navegando hasta la carpeta activate 



		'Primeras Pruebas de Ejecución de una API Básica con el Método GET'
		'Instalar FastApi'

			-Devemos escribir en el comando - pip install fastapi -
			-Luego de instalar fastapi devemos instalar devemos instalar un servidor ASGI que da soporte a la libreria '(Uvicorn)'
			-Devemos escribir en los comandos - pip install "uvicorn[standard]" -


			-Ahora vamos a hacer unas importaciones 

				Ej :

				from typing import Union
				from fastapi import FastAPI

			-Ahora vamos a escribir nuestro primer codigo con fastapi.
			-Vamos a crae un objeto de una clase de fastapi
			-Y vamos a crear la primera ruta, que esto se hace con como atributos, como marcadores de funciones '(@)' con el metodo get
			 @app.get('/'), esto es una ruta raiz, podesmos hacer agregaiones por ejemplo @app.get('/Hola'), y asi es como vamos a acceder
			 al la ruta.
			-Los metodos get son para solicitar datos. 


				#Creacion de una aplicacion FastAPI
				app = FastAPI()

			
				@app.get('/')
				def read_root():
				    return {'Hello' : 'World'} 


			-Para ejecutar este codigo vemos escribir en la terminal - uvicorn main:app --reload -
			-  --reload esto es una bandera que nos sirve para que cada ves que hagamos cambios y refresquemos lo haga automaticamente  



			-Lo que vamos a hacer ahora es crear una ruta que recibe un parameto, que es una variable por lo tanto esto se va a llegar 
			 dinamicamente 

			-Para colocar variables lo hacemos entre llaves 
				app.get('/items/{item_id}') #Estos son pametros de ruta


			- Ahora vamos a crear una funcion que recibe como parametros a item_id y que el tipo de dato es un int '(En este caso no puede ser none)'.
			-Y para el segundo parametro vamos a decir que el tipo de datos que recibe 'q' puede ser tipo string o puede ser NONE

				ejemplo
					@app.get('/items/{item_id}')
					def read_item(item_id: int, q: Union[str, None] = None): #Estos son parametros de consulta 
					    return {'item_id': item_id, 'q': q}

			-Y luego retornamos el item_id lo que haya digitado el usuario lo pasamos al parametro de @app.get('/items/{item_id}')

			-Entonces ahora hemos creado con ello una ruta en la que el usuario especipficara el id que desee, lo vamos buscar 
			 asi http://localhost:8000/items/100


			-Para insertar el valor de q (Su nombre es parametro de consulta = query params) devemos agregar 
			  http://localhost:8000/items/100?q=mouse

			 
			 	ejemplo de como para entender a grande rasgos:

			 		@app.get('/calculadora') 
					def calcular(operando_1: float, operando_2:float): #Estos son parametros de consulta 
					    return {'suma': operando_1 + operando_2}

			-Esta ves vamos a tener que usar esta ruta http://localhost:8000/calculadora?operando_1=1000&operando_2=10000		    


			'Tipo de parametros'
				-Los tipos de parametros de ruta se separan con el separador de ruta '/'
				-Los tipos de parametros de consultas empiezan con un signo de pregunta '?'y se separan con un '&'
				-app.get('/items/{item_id}') - Estos son paametros de ruta -
				-http://localhost:8000/calculadora?operando_1=1000&operando_2=10000 - Estos son parametro de consulta -



			'Ruta para Documentación Alternativa de API con ReDoc (OpenAPI)'

				-Con esta ruta podemos acceder a la documentacion interactiva, eso es una documentacion que se crear automaticamente 
				 para que podamos hacer pruevas sencillas de nuestro codigo, a su ves tambien nos provee informacion adicional para 
				 el mejoramiento y aplicacion de nuevos reursos 
				  - http://localhost:8000/docs#/ -



			'Creando una Ruta Tipo PUT para Actualizar Datos - Creación Modelo Personalizado'
				-Ahora vamos a utilizar pydantic para especifiacar el cuerpo de una solicitud y tambien de una respuesta, basicamente 
				pydantic nos permite trabajar de maneta homogenia con los tipos de datos y el tipo de informacion que se intercambia 
				'(con la infromacion que se envia y con la informacion que se recibe)'


			-Ahora vamos a moficar el archivo main.py para recibir un curpo de una solicitus PUT.
			 PUT = actuaizar datos o modificar datos existentes	
			 POST = Crear 


			-Lo que vamos a ahacer es importar a BaseModel desde pydantic
			
				ejemplo


					from pydantic import BaseModel    	


				BaseModel : 
							BaseModel es una clase proporcionada por la biblioteca Pydantic, que es una biblioteca de validación y 
							serialización de datos en Python. La clase BaseModel se utiliza para definir modelos de datos en Pydantic, 
							y estos modelos se utilizan comúnmente en el contexto de aplicaciones web, especialmente en combinación con 
							frameworks como FastAPI.

							Cuando defines una clase que hereda de BaseModel, estás creando una estructura de datos con atributos y 
							sus tipos asociados. Pydantic utiliza estas definiciones de modelo para validar datos de entrada, 
							realizar conversión de tipos y generar automáticamente documentación interactiva.	


			-Ahora lo que vamos a hacer es crear una clase con la clase BaseModel 

				ejemplo:

					class Item(BaseModel):
					    name: str
					    price: float
					    is_offer: Union[bool, None] = None


			-Ahora vamos a crear una ruta para actualizar 
			-En este caso si deseaos mas informacion como estamos haciendo referencia a la clase que acabamos de crear y la clase tiene 
             atributos, podemos acceder a ese tipo de imfomacion tambien *

				ejemplo:

					@app.put('/item/{item_id}')
					def update_item(item_id: int, item: Item):
					    return {'item_name': item.name, 'item_id': item_id, #EJ* 'item_price': item.price}

					-Para simplificar :  'item_id' nos indica cual es la inforacion que queremos actualizar
										 'item: Item' viajan los datos, los campos de la clase que queremos actualizar


		
		'Organizar en una Carpeta los Modelos que Integran la API- Importación de un Modelo'

			-Nosotros podemos colocar el codigo en un solo archivo, por lo tanto va a depender del tipo de aplicacion o de api que 
			 estemos diseniando el tamanio.


			
			-Tambien otra forma de abordar este tema es colocar los modelos en un modulo'(archivo)' aparte.
			-Lo que hacemos es definir las clases o la estructura en otro archivo.
			-Creamos una carpeta 'models' y dentro de esta un archivo 'item_model.py', ahi pasamos la clase 'Item' e importamos a
			 from pydantic import BaseModel 

			-Cuando creamos un modulo en python devemos crear un archivo __init__.py
			-Tambien por lo tanto al crear un modulo aparte, donde realizamos las solucitudes o metodos devemos importar este archivo.
				
				ejemplo
					from models.item_model import Item   

					  	




"Curso de fastAPI en udemy"


	-'Nota del profesor Y personal': Lo perimero que devemos hacer, es plantearnos como acceder o como llegar al lugar que deseamos
	 del elemento iterable manualmente.

	
	'Estructura de datos python'

	-Lista de lista 

		ej:	
			notas = [
			    ['Calculo', 3.2, 4.1, 0.2],
			    ['Quimica', 5.2, 9.1, 1.2],
			    ['Deporte', 3.9, 1.1, 7.2],
			    ['Logica', 8.2, 4.0, 4.2]
			]

			def c11_final():
			    global notas
			    for i in range(len(notas)):
			        nota1 = notas[i][1] * 0.3
			        nota2 = notas[i][2] * 0.3
			        nota3 = notas[i][3] * 0.4
			        nota_final = nota1 + nota2 + nota3
			        notas[i].append(nota_final)


			def c12_promedio():
			    global notas
			    nota_suma = 0
			    for nota_promedio in notas:
			        nota_suma += nota_promedio[4]
			    print('El promedio es : ', nota_suma)


			c11_final()
			c12_promedio()



	'Diccionario de lista'
		

		notas = {
        'Calculo': [3.2, 4.1, 0.2],
        'Quimica': [5.2, 9.1, 1.2],
        'Deporte': [3.9, 1.1, 7.2],
        'Logica': [8.2, 4.0, 4.2]
		}


		def c21_final():
		    global notas
		    for materia, i in notas.items():
		        nota1 = i[0] * 0.3
		        nota2 = i[1] * 0.3
		        nota3 = i[2] * 0.4
		        nota_final = nota1 + nota2 + nota3

		        notas[materia].append(nota_final)


		def c22_promedio():
		    global notas
		    suma_notas = 0
		    for materia, i in notas.items():
		        suma_notas += i[3]

		    print('El promedio es: ', suma_notas / len(notas))


		c21_final()
		c22_promedio()	



	'diccionario de diccionrio'

		notas = {
				    'calculo': {'pp': 3.5,
				                'sp': 2.5,
				                'tp': 1.5},
				    'quimica': {'pp': 1.5,
				                'sp': 7.5,
				                'tp': 0.5},
				    'deporte': {'pp': 1.1,
				                'sp': 0.5,
				                'tp': 9.5},
				    'logica': {'pp': 1.1,
				               'sp': 10.5,
				               'tp': 19.5},
				}


				def c31_final():
				    global notas
				    for nota, value in notas.items():
				        nota1 = value['pp']*0.3
				        nota2 = value['sp']*0.3
				        nota3 = value['tp']*0.4
				        nota_final = nota1 + nota2 + nota3

				        notas[nota]['final'] = nota_final


				def c32_promedio():
				    global notas
				    suma_notas = 0
				    for key, value in notas.items():
				        suma_notas += value['final']

				    print('El promedio es : ', suma_notas / len(notas))


				c31_final()
				c32_promedio()



	'Lista de diccionario'

		notas = [
		         {'nombre': 'calculo',
		             'pp': 3.5,
		             'sp': 2.5,
		             'tp': 1.5},
		         {'nombre': 'quimica',
		             'pp': 1.5,
		             'sp': 0.5,
		             'tp': 9.5},
		         {'nombre': 'deporte',
		             'pp': 3.12,
		             'sp': 2.98,
		             'tp': 11.15},
		         {'nombre': 'logica',
		             'pp': 12.5,
		             'sp': 2.51,
		             'tp': 10.5},
		]


		def c41_final():
		    global notas
		    for i in range(len(notas)):
		        nota1 = notas[i]['pp']*0.3
		        nota2 = notas[i]['sp']*0.3
		        nota3 = notas[i]['tp']*0.4
		        nota_final = nota1 + nota2 + nota3

		        notas[i]['nota_final'] = nota_final


		def c42_promedio():
		    global notas
		    suma_notas = 0
		    for i in range(len(notas)):
		        suma_notas += notas[i]['nota_final']

		    print('El promedio es : ', suma_notas / len(notas))
		    
		    
		c41_final()
		c42_promedio()


	'Creacion de nuestra primera API'

		-Lo primero de que devemos hacer es tener una carpeta en donde nosotros vamos a crear nuestro proyecto.
		-Luego devemos crear un entorno virtual con el comando - virtualenv venv -, y  lo devemos activar con el comando 
			- .\venv\Scripts\activate -

		
		-Luego vamos a craer un archivo de texto para hacer refeencia a las libreriass que vamos a utilizar e instalar en el entorno virtual,
		 para que luego podamoa ver nosotros y otras personas las librerias que hemos utilizado y a demas de llevar un control.
		 Crearemos un archivo de texto llamado - requeriments.txt, y vamos a espezar agregando a la lista -fastapi-, tambien devemos tener en
		 cuenta que fastapi funciona con otra libreria que es - uvicorn -



		-uvicorn : Lo que hace uvicorn es levantar el servidor para correr nuestra aplicacion fastapi 

		-Despues de ello lo que devemos hacer es instalar todo lo del archivo requirments en nuestro entorno virtual con el comando 
		  - pip install -r requeriments.txt -  	 


		-Luego vamos a crar un archivo en donde vamos a dar inicio a toda nuestra aplicacion de fastapi llamado main.py
		
		-Luego vamos a importar fastapi.

			ej:

				from fastapi import FastApi


		-Luego vamos a crear un ebjeto llamado con lo que acabamos de importar
			
			ej:

				app = FastAPI()


		-Luego de crear el objeto vamos a coorer nuestra app con uvicorn
			
			ej:
				-En la terminal vamos a tener en cuenta. - Mira hay un archivo de python (en este caso es main) pero dentro de ese archivo de
				 python esta nuestra aplicacion app, entoces colocamos en consola.

				 	- uvicorn main:app -

		-La otra forma de levantar nuestro servidor es, que importemos a uvicorn

			ej:

				from fastapi import FastAPI
				import uvicorn

				app = FastAPI()

				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000)

				
				-Y para ejecutar esto devemos poner en comando y automaticamente corre el servidor.

					ej:

						- python .\main.py -    


		-Para crear una api directamente podemos colocar @app.get('/ruta1'), despues de crear como tal nuestr aplicacion devemos crear una
		 una funcion por ejemplo ruta1.

		 	ej:

			 		@app.get('/ruta1')
					def ruta1():
					    return {'Hola mundo'}		




		-Si nosotros asicmo tenemos nuestra api, modificamos agregamos, o elimnamos algo , no se va a ver reflejado los cambios en el puerto
		-Para que eso suceda automaticamente devemos 

			ej:

				from fastapi import FastAPI
				import uvicorn

				app = FastAPI()

				@app.get('/ruta1')
				def ruta1():
				    return {'Hola mundo'}
				    --------------------------------------------------
				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True)			    	

				    --------------------------------------------------	
			-El reload es para que el servidir interprete los cambios que yo ya tengo y automaticamente lo reinicie
			-Ya con esto volvemos a refrescar y ya esta la actualizacion. 


		-Si quiero recibir un parametro en mi api, devemos utilizar el metodo POST.
		
			ej:

				@app.post('/ruta2')
				def ruta2(user):
				    print(user)
				    return True	

			-Cuendo despleguemos la de tipo post, nos va a decir que un campo es requerido, que es un parametro de tipo query,
			 si a ese campo le enviamos algo por ejemplo andres y ejecuto automaticamente como es de tipo query lo que va a hacer es 
			 concatenar en la url entonces quedaria asi 

			 		-  http://127.0.0.1:8000/ruta2?user=andres - 


		-Pero si queremos definir mas campos, podemos implementar pydantic y definir un modelo con el cual nosotros vamos a recibir los datos
		-Para ello vamos a importar a pydantic	 		
 	    	
 	    	ej:

 	    		from pydantic import BaseModel

 	    	-BaseModel es la clase en la cual nosotros vamos a basar los modelos 
 	    	-Pydantic es una biblioteca de python que nos permite basarnos en un esquema que nosotros hemos definidode escribir los datos 
 	    	 para luego usarlos 

 	    	-Para usar BaseModel, devemos crear un modelo de usuario y vamos a definir una clase que va a heredar de BaseModel.
 	    	 Y luego vamos a definir los parametros que queremos que nos llegue , por ejemplo id:int, si quiero otro parametro que llega
 	    	 le coloco tambien el parametro y el tipo de dato por ejemplo nombre:str y si quiero otro hacemos lo mismo por ejemplo 
 	    	 apellido:str, despues de ello queremos definir otro parametro pero que sea opcional devemos importar otra libreria que se llama 
 	    	 - from typing import Optional -  y ahi ya podriamos definir un parametro que sea opcional que se puede o no enviar por ejemplo 
 	    	 direccion:Optional[str], otro ejemplo pero con typo int, telefono:int 

 	    	-Si nosotros queremos implementar un parametro datetime y queremos como una fecha por defecto, lo que tendriamos que hacer, 
 	    	primero importar a datetime - from datetime import datetime -
			despues de ello lo que tenemos que hacer es crear el parametro por ejemplo , creacion_usuario:datetime=datetime.now()
			entonces asi se define por defecto automaticamente

				ej:

					from fastapi import FastAPI
					import uvicorn
								-------------------------------------------------------------------
					from pydantic import BaseModel
					from typing import Optional
					from datetime import datetime

					# User Model
					class User(BaseModel):
					    id:int
					    nombre:str
					    apellido:str
					    direccion:Optional[str]
					    telefono:int
					    creacion_user:datetime=datetime.now()

					    		-------------------------------------------------------------------
					app = FastAPI()

					@app.get('/ruta1')
					def ruta1():
					    return {'Hola mundo :)'}

					@app.post('/ruta2')
					def ruta2(user):
					    print(user)
					    return True

					if __name__ == '__main__':
					    uvicorn.run('main:app', port=8000, reload=True)	 
												

		-Para implementar el esquema que creamos con pydantic directamente con nuestra api y decirle vea estos son los parametros que vamos a 
		 necesitar. Directamente cuando le pasamos el parametro a la funcion de la api le decimo que va a ser igual a la clae que acabamos de crear	
		 con los parametros 


		 	ej:

		 		from fastapi import FastAPI
				import uvicorn
				from pydantic import BaseModel
				from typing import Optional
				from datetime import datetime

				# User Model
				class User(BaseModel):
				    id:int
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    creacion_user:datetime=datetime.now()


				app = FastAPI()

				@app.get('/ruta1')
				def ruta1():
				    return {'Hola mundo :)'}
				    		------------------------------------------------
				@app.post('/ruta2')
				def ruta2(user:User):
				    print(user)
				    return True
				    		------------------------------------------------
				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True)									

		-Despues de ello nosotros podemos agregar el valor a los parametros 

			ej:
				{
				  "id": 1,
				  "nombre": "neyen",
				  "apellido": "frandino",
				  "direccion": "alaska",
				  "telefono": 4524375,
				  "creacion_user": "2023-12-09T15:50:56.297059"
				}

			-Y para acceder a esos datos usando la clase y haciendo refencia a la imformacion de queremos obtener por ejemplo 


					ej:
						from fastapi import FastAPI
						import uvicorn
						from pydantic import BaseModel
						from typing import Optional
						from datetime import datetime

						# User Model
						class User(BaseModel):
						    id:int
						    nombre:str
						    apellido:str
						    direccion:Optional[str]
						    telefono:int
						    creacion_user:datetime=datetime.now()


						app = FastAPI()

						@app.get('/ruta1')
						def ruta1():
						    return {'Hola mundo :)'}

						@app.post('/ruta2')
						def ruta2(user:User):
							----------------------------------------------------------------------------
						    print(user.nombre, user.apellido, user.direccion, user.creacion_user, user.id)
						    ----------------------------------------------------------------------------
						    print(user)
						    return True

						if __name__ == '__main__':
						    uvicorn.run('main:app', port=8000, reload=True)


					-Para traformar toda la informacion que le estoy pidiendo en un diccionario  
					 print(user.nombre, user.apellido, user.direccion, user.creacion_user, user.id),
					 solo tengo que decirles user.dict()	

					-Podemos asignarle una variable al user.dict() para luego poder hacer uso de ella mas simple mas ordenado.
						
						ejemplo:

    						usuario = dict(user)

	'Implementación de api para devolver un usuario'


		-Lo que vamos a hacer a continuacion es añadir la respues de la api con los datos a una lista, con esto estariamos creando un usuario

			ejemplo:

				from fastapi import FastAPI
				import uvicorn
				from pydantic import BaseModel
				from typing import Optional
				from datetime import datetime

				# User Model
				class User(BaseModel):
				    id:int
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    creacion_user:datetime=datetime.now()

				app = FastAPI()
							--------------------------------------------
				usuarios = []
							-------------------------------------------
				@app.get('/ruta1')
				def ruta1():
				    return {'Hola mundo :)'}
				    ------------------------------------------------------------
				@app.post('/cerar_usuario')
				def crear_usuario(user:User):
				    usuario = dict(user)
				    usuarios.append(usuario)
				    return {'Respuesta: Usuario creado exitosamente!!'}
				    -------------------------------------------------------------
				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True)


		-Ahora vamos a crear una api para devolver todos los datos de los usuarios para ver si se han creado correstamente 
		- Entonces ahora vamos a definir una ruta de tipi -user- y le creamos una funcion -obtener_usuarios- y simpemente hacemos que nos retorne
		  la lista que habiamos creado y habiamos estado alimentando con los usuarios creados.

		-Por lo tanto, si corremos esta api nos va a devovler la informacion que entro en la api crear_usuario.
		 NOS VA A DEVOLVER UNA LISTA DE DICCIONARIOS EN EL QUE CADA INDICE VA A REPRESENTAR UN USUARIO   

		  	ej:

		  		from fastapi import FastAPI
				import uvicorn
				from pydantic import BaseModel
				from typing import Optional
				from datetime import datetime

				# User Model
				class User(BaseModel):
				    id:int
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    creacion_user:datetime=datetime.now()

				app = FastAPI()
				usuarios = []

				@app.get('/ruta1')
				def ruta1():
				    return {'Hola mundo :)'}
				    					-----------------------------------------------------
				@app.get('/user')
				def obtener_usuarios():
				    return usuarios
				    					-----------------------------------------------------
				@app.post('/cerar_usuario')
				def crear_usuario(user:User):
				    usuario = dict(user)
				    usuarios.append(usuario)
				    return {'Respuesta: Usuario creado exitosamente!!'}

				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True)


		-Devemos tener en cuenta que esta ejecucion de la api en la que se guardan los usuarios en una lista, si nosotros al hacer un cambio
		 en nuestra app, automatiicamente se elimina todo lo de la lista. Este es un metodo de ejemplo. 




		-Para obtener un usuario en especial por su id, lo que vamos a hacer es crear otra api de tipo post por que vamos a recibir datos , 
		 pero ademas de ello nosotros vamos a decirle va a venir como query parametro, le vamos a crear una funcion que se va a llamar
		 - obtener_usuario_por_id - y le vamos a pasar un parametro que sea - user_id:int-,
		   y  vamos a empesar a recorres toda la lista que tenemos para buscar.

		 -query parametro: es que esta llegando directamente la url y que lo vamos a entender 
		 -Esta es una de las formas para obtener un usuario	
		 -Cuando utilizamos query parametro es permitido realizarlo con un metodo de tipo get, PERO NO ES PERMITIDO HACER UNA CONSULTA 
		  ENVIANDO EL PARAMETRO TYPO BODY


		 	ej:

		 		from fastapi import FastAPI
				import uvicorn
				from pydantic import BaseModel
				from typing import Optional
				from datetime import datetime

				# User Model
				class User(BaseModel):
				    id:int
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    creacion_user:datetime=datetime.now()

				app = FastAPI()
				usuarios = []

				@app.get('/ruta1')
				def ruta1():
				    return {'Hola mundo :)'}

				@app.get('/user')
				def obtener_usuarios():
				    return usuarios

				@app.post('/cerar_usuario')
				def crear_usuario(user:User):
				    usuario = dict(user)
				    usuarios.append(usuario)
				    return {'Respuesta: Usuario creado exitosamente!!'}
				    					-------------------------------------------------------------------------
				@app.post('/user/{user_id}')
				def obtener_usuario_por_id(user_id:int):
				    for user in usuarios:
				        print (user['id'])
				        if user['id'] == user_id:
				            return {'Usuario ': user}
				        return{'Usuario: no encontrado'}
				        				-------------------------------------------------------------------------

				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True)	 


		-Pero tambien enves de enviarlo como query parametro, si no como typo json lo que vamos a hacer simplemente es volver a crear un modelo	
		 en donde solamente el contenido de ese modelo va a ser el usuario id 

		-Cuando utilizamos query parametro es permitido realizarlo con un metodo de tipo get, PERO NO ES PERMITIDO HACER UNA CONSULTA 
		 ENVIANDO EL PARAMETRO TYPO BODY  		|
		 										V
		 	ej:
				from fastapi import FastAPI
				import uvicorn
				from pydantic import BaseModel
				from typing import Optional
				from datetime import datetime

				# User Model
				class User(BaseModel):
				    id:int
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    creacion_user:datetime=datetime.now()
				    			--------------------------------------------------------------------
				class User_id(BaseModel):
				    id:int    
				    			--------------------------------------------------------------------
				app = FastAPI()
				usuarios = []

				@app.get('/ruta1')
				def ruta1():
				    return {'Hola mundo :)'}

				@app.get('/user')
				def obtener_usuarios():
				    return usuarios

				@app.post('/cerar_usuario')
				def crear_usuario(user:User):
				    usuario = dict(user)
				    usuarios.append(usuario)
				    return {'Respuesta: Usuario creado exitosamente!!'}

				# @app.post('/user/{user_id}')
				# def obtener_usuario_por_id(user_id:int):
				#     for user in usuarios:
				#         print (user['id'])
				#         if user['id'] == user_id.id:
				#             return {'Usuario ': user}
				#         return{'Usuario: no encontrado'}
				    
											--------------------------------------------------------
				@app.post('/user')
				def obtener_usuario_por_id_2(user_id:User_id):
				        for user in usuarios:
				            print (user['id'])
				            if user['id'] == user_id.id:
				                return {'Usuario ': user}
				            return{'Usuario: no encontrado'}
				            				---------------------------------------------------------

				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True)




	'Implementación de apis eliminar y actualizar'


		'Eliminar un usuario'

		-Para eliminar un usuario vamos a crearla api que seria -delete- y le ponemos en la ruta -user- y como query parametro le vamos 
		 a pasaer -user_id-, creamos la funcion que le podemos poner de nombre -eliminar_usuario- y como parametro de la funcion le vamos a pasar 
		 -user_id:int- ahora nosotros devemos recorrer la lista que hemos creado pero para eliminar devemos tener el indice y el valor para saber 
		  si el id que nosotros estamos enviendo va a ser igual al que en el momento que nosotros estamos recooriendo el en for entonces ahi, poder
		  crear la centencia eliminar

		  	ej:


				from fastapi import FastAPI
				import uvicorn
				from pydantic import BaseModel
				from typing import Optional
				from datetime import datetime

				# User Model
				class User(BaseModel):
				    id:int
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    creacion_user:datetime=datetime.now()

				class User_id(BaseModel):
				    id:int    

				app = FastAPI()
				usuarios = []

				@app.get('/ruta1')
				def ruta1():
				    return {'Hola mundo :)'}

				@app.get('/user')
				def obtener_usuarios():
				    return usuarios

				@app.post('/cerar_usuario')
				def crear_usuario(user:User):
				    usuario = dict(user)
				    usuarios.append(usuario)
				    return {'Respuesta: Usuario creado exitosamente!!'}

				# @app.post('/user/{user_id}')
				# def obtener_usuario_por_id(user_id:int):
				#     for user in usuarios:
				#         print (user['id'])
				#         if user['id'] == user_id.id:
				#             return {'Usuario ': user}
				#         return{'Usuario: no encontrado'}
				    

				@app.post('/user')
				def obtener_usuario_por_id_2(user_id:User_id):
				        for user in usuarios:
				            print (user['id'])
				            if user['id'] == user_id.id:
				                return {'Usuario ': user}
				            return{'Usuario: no encontrado'}
				            	------------------------------------------------------------------
				@app.delete('/user/{user_id}')
				def eliminar_usuario(user_id:int):
				    for index, user in enumerate(usuarios):
				        if user['id'] == user_id:
				            usuarios.pop(index) 
				            return{'Respuesta: El usuario a sido eliminado correctamente'}
				    return{'El usuario no se ha encontrado'}
				    			------------------------------------------------------------------

				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True)


	'Actualizar un usuario'
		
		-Lo primero que vamos a hacer va a ser crear la ruta de nuestra app con -@app.put('/user/user_id')- le colocamos un parametro de ruta	
		 por que necesitamos saber a que usuario va a hacer referencia para modificar, luego vamos a crear su respectiva funcion y la vamos 
		 a llamar -	actualizar_usuario(user_id:int, updateUser:User ) y lo valores que nosotros queremos actualizar a actualizar va a ser igual al modelo que 
		 hemos creado con el nombre de -User(BaseModel)- 

		-Ahora necesitamos reccorer los datos que tengamos, en donde los tengamos con un for, como el que usamos en la api delete.
		 Pero en este caso vamos a tener en cuenta todos los atributos del esquema User(BaseModel) para asi poder el usuario modificar el campo que desee.

		-Tenemos que tener en cuenta que con este metodo que estamos creando, tambien se esta modificando el nomero de id, por lo tanto si nosotros,
		 no le especificamos el numero de id correspondiente el por defecto le va a dar el numero 0, si no tenemos esto en cuenta en el foturo y no lo hacemos
		 que se llene dinamicamente esto nos podria traer algunos problemas. 

		 	ej:

		 		from fastapi import FastAPI
				import uvicorn
				from pydantic import BaseModel
				from typing import Optional
				from datetime import datetime

				# User Model
				class User(BaseModel):
				    id:int
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    creacion_user:datetime=datetime.now()

				class User_id(BaseModel):
				    id:int    

				app = FastAPI()
				usuarios = []

				@app.get('/ruta1')
				def ruta1():
				    return {'Hola mundo :)'}

				@app.get('/user')
				def obtener_usuarios():
				    return usuarios

				@app.post('/cerar_usuario')
				def crear_usuario(user:User):
				    usuario = dict(user)
				    usuarios.append(usuario)
				    return {'Respuesta: Usuario creado exitosamente!!'}

				# @app.post('/user/{user_id}')
				# def obtener_usuario_por_id(user_id:int):
				#     for user in usuarios:
				#         print (user['id'])
				#         if user['id'] == user_id.id:
				#             return {'Usuario ': user}
				#         return{'Usuario: no encontrado'}
				    

				@app.post('/user')
				def obtener_usuario_por_id_2(user_id:User_id):
				        for user in usuarios:
				            print (user['id'])
				            if user['id'] == user_id.id:
				                return {'Usuario ': user}
				            return{'Usuario: no encontrado'}

				@app.delete('/user/{user_id}')
				def eliminar_usuario(user_id:int):
				    for index, user in enumerate(usuarios):
				        if user['id'] == user_id:
				            usuarios.pop(index) 
				            return{'Respuesta: El usuario a sido eliminado correctamente'}
				    else:    
				        return{'El usuario no se ha encontrado'}

				        		----------------------------------------------------------------------------------------
				@app.put('/user/{user_id}')
				def actualizar_usuario(user_id:int, updateUser:User):
				    for index, user in enumerate(usuarios):
				        if user['id'] == user_id:
				            usuarios[index]['id'] = dict(updateUser)['id']
				            usuarios[index]['nombre'] = dict(updateUser)['nombre']
				            usuarios[index]['apellido'] = dict(updateUser)['apellido']
				            usuarios[index]['direccion'] = dict(updateUser)['direccion']
				            usuarios[index]['telefono'] = dict(updateUser)['telefono']
				            return{'Respuesta: El usuario ha sido modificado correctamente'}
				    else:
				        return{'El usuario no se ha encontrado'}
				            
				        		-------------------------------------------------------------------------------------------
				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True)
    

    'Creacion de router'

    		-Lo que vamos a hacer ahora va a ser estructurar el codigo. Por que actualmente tenemos en el archivo main.py
    		-Basicamente lo que vamos a hacer es empezar a crear carpetas y vamos a defiir donde van a estar sus respectivas rutas, por ejemplo
    		 todo lo que tiene que ver con los usuarios vamos a crear un router que se encargue de toda la gestion de los usuarios, como por ejemplo en un
    		 futuro podemos hacer un router que se encargue de otra funcionalidad, y lo unico que tendriamos que hacer es despues de crear el router añiadirlo
    		 como tal nuestra aplicacion.




    		-Vamos crear una nueva carpeta llamada -app-, en esta nueva carpeta vamos a crear otra carpeta que se llame -routers- y dentro de la carpeta 
    		 app vamos a crear otra carpeta que se llame -repository-.

    		-Dentro de la carpeta routers vamos a crear un archivo que va a ser el - __init__.py - para que entienda que esto que estamos colocando es un 
    		 modulo de python y en repository hacemos lo mismo - __init__.py - 

    		-Despues vamos a crear otro archivo dentro de la carpeta routers que se llame - user.py - y despues lo que vamos a hacer es copiar todas las rutas
    		 que hemos estado creando y pegarla en esta  carpeta. 

    		-Tenemos que tener en cuenta que tenemos que declarar una -apirouter- y eso lo podemos traer directamente de fastapi, entonces lo que hacemos es 
    		 -from fastapi import APIRouter- y a continuacion definimos nuestro router - router = APiRouter(prefix= "/user",
    		 																								tags=["Users"])-
    		 ahora enves de hacer referencia app para crear nuestra ruta, devemos hacer referencia a router

    		-Como estamos definiendole un prefix "/user" lo que podemos hacer para que no sea redundante, es de nuestras api eliminar la referencia 
    		 "/user" ya que definimos por defecto que se coloque como nombre de ruta "/user" en el prefix 	


    		 	Ej:

    		 		from fastapi import APIRouter

					router = APIRouter(prefix="/user",
					                   tags=["users"])




    		-Otra cosa muy emportante es que nosotros dentro de nuestras api estamos usuando esquemas, pero en este momento tenemos los esquemas en el 
    		 archivo main.py entonces lo que vamos a hacer es crear un nuevo archivo dentro de la carpeta app que se llame - schemas.py - que va a ser 
    		 donde vamos a definir los esquemas. Y vamos a pegar todos los schemas que habiamos creado, tambien nos devemos llevar a esa carpeta el BaseModel

    		 	ej de como se ve este archivito:

    		 		from pydantic import BaseModel
					from typing import Optional
					from datetime import datetime

					# User Model
					class User(BaseModel):
					    id:int
					    nombre:str
					    apellido:str
					    direccion:Optional[str]
					    telefono:int
					    creacion_user:datetime=datetime.now()

					class User_id(BaseModel):
					    id:int    

			-Ahora lo que devemos hacer es importar este modulo	(archivo) a nuestro archivo user.py
				
				ej:
					from app.schemas import User, user_id

			-Lo otro que deveriams hacer es incluir nuestra ruta a nustra aplicacion, como hacemos esto, directamente colocamos en el archivo main.py 
			 - app.include_router(user.router) -	y devemos importar a router de la carpeta user.py -from app.routers import user  -

			 	Ej de como quedaria el archivo main.py:

			 	from fastapi import FastAPI
				import uvicorn
				from app.routers import user


				app = FastAPI()
				app.include_router(user.router)


				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True)

			-Luego devemos correr nuestro servidor. 





	'Instalacion de postgres'
		
		-Para crear un sql script voy a sql en la interfaz de dBeaver y me aparece directamente una ventana para ejecutar directamente las consultas sql
		-Podemos crear diferentes conecciones a bases de datos y podemos crear tambien diferentes bases de datos. Por lo tanto para hacer referencia a una 
		 o a otra devemos establecerla por defecto con le click derecho en la base de datos que creemos y estableces por defecto .	


	'Conexión a postgres y creación de modelo usuario'
		
		-Ahora lo que vamos a hacer es conectar directamnte toda nuestra aplicacion con la base de datos que esta en postgres, pero pasa hacer la conexion 
		 nosotros principalmente tenemos que instalar dos librerias mas muy importantes.	
		-Primero devemos agregar las librerias a requeriments.txt 
			ej:

				fastapi
				uvicorn
					----------------
				psycopg2
				SQLALchemy  
					----------------

		-Luego de ello lo que tendriamos que hacer es es instalar. - pip install -r .\requeriments.txt -
		
		-Despues de ello lo que tenemos que hacer es que en nuestra carpeta app , vamos a crear otra carpeta que se llame -db- que va a ser la encargada 
		 de todo lo que tiene que ver con los modelos y la coneccion a la base de datos
		-Luego creamo nuestro primer archivo que lo vamos a llamar - models.py -, 
		-Aqui en este ultimo archivo nos tenemos que traer principalmente nuestro usuario, el modelo de esquema de usuario esto lo habiamos creado en
		 el archivo schemas.py.
		 Lo que hacemos primeramente es copiar el esquema de usuario y pegarlo en nuestra carpeta models.py comentado 

		 	ej de como se veria hasta el momento nuestro achivo models.py:

				""""
				class User(BaseModel):
				    id:int
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    creacion_user:datetime=datetime.now()

				"""			



		-Nuestro modelo se tiene que heredar para que toda nuestra aplicacion entienda a que base de datos nosotros nos estamos refiriendo, para ello vamos
		 a crear otro archivo dentro de db que se llame - database.py - 
		-Ahora vamos a database.py y lo perimero que vamos a hacer es importar desde SQLALchemy a - from sqlalchemy import create_engine - 
		 y taambien nos vamos a importar - from sqlalchemy.ext.declarative import declarative_base - y tambien - from sqlalchemy.orm import sessionmaker -

		-Desúes de ello lo que vamos a hacer es crearnos una variable llamada - SQLALCHEMY_DATABASE_URL - que va a ser la encargada de la conexion
		 a esta variable le vamos a indicar lo siguiente - le colocamos primero donde esta actualmente nuesra base de dato ("postgresql:" ) despues de ello 
		 nosotros tenemos que colocar es el usuario teniendo en cuenta que cuando nosotros nos conectamos con la base de datos en dBeaver devemos ir a la 
		 base de datos que en este caso es - postgres-localhost:5432 - ahi hacemos click derecho y vamos a editar conection y de ahi sacamos el usuario y 
		 la contraseña, despues viene la url que en este caso es - localhost -, luego viene el puerto que en este casi es - 5432 -, y por ultimo viene el 
		 nombre de la bbase de datos que en este caso es - fastapi-database -
		 
		-Esto es como tal nuestra url de la base de datos 

		-Despues de ello vamos a crear una variable que se llame - engine - y que tena el valor create_engine(SQLALCHEMY_DATABASE_URL)
		-El engine es principalmente es el encargado de crear las tablas de hacer los select a las tablas de interactual con la base de datos 

			ej:
				engine = create_engine(SQLALCHEMY_DATABASE_UR)

		
			ej de como se tiene que ir viendo nuestro archivo database.py 

				from sqlalchemy import create_engine
				from sqlalchemy.ext.declarative import declarative_base
				from sqlalchemy.orm import sessionmaker
				SQLALCHEMY_DATABASE_URL = "postgresql://postgres:Neyen1995@localhost:5432/fastapi-database"

				engine = create_engine(SQLALCHEMY_DATABASE_UR)
		

		-Despues de ello nosotros vamos a tener un session que va a ser el encargado de interactuar con la base de datos tambien pero el principal motivo 
		 es saber como estan los datos actualmente ej: si nosotros creamos un nuevo usuario mediante y lo veremos cuando lo estemos creando, nosotros 
		 tenemos la potestad de deirle guardelo o no lo guarde, nosotros podemos crear un objeto del usuario y despues de crearlo no significa que ya esta
		 guardado sino que tendremos que darle un commit .

		-Entonces vamos a declarar una variable con el nombre - SessionLocal - que va a ser un objeto de sessionmaker() y destro de los parentecis
		 el - bind=engine, autocommit=False, autoflush=False -				

		 	ej:

		 		SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False )

		-Despues de ello vamos a declarar - Base - que nuestro Base va a ser como tal nuestro - declarative_base() -
		-Este es el Base con el cual nosotros vamos a comenzar a crear nuestros modelos por este es el que tiene que comenzar a heredar 	
			
			ej:	
				Base = declarative_base()

		


		-Entonces ahora vamos a nuestros archivo models.py y lo principal que nosotros devemos hacer es traernos ese Base entonces le decimos 
		 - from app.db.models import Base -		


		-Ahora ya teniendo esto vamos a declarar nuestra primera tabla - class User(Base): - que va a heredar de Base
		-Depsues de llo lo que nosotros tenemos que colocarle es un nombre a la tabla - __tablename__= 'User' - 

			ej:

				class User(Base): 
    				__tablename__= 'User'


		-Tambien devemos traernos algo de sqlalchemy que es para indicar cuando nosotros estamos declarando los modelos si es de tipo columna , si la 
		 columna es de typo de datos int, text, datetime etc. 

		 	ej:

		 		from sqlalchemy import Column, Integer, String, Boolean, DateTime

		-Despues de ello empezamos a crear nuestra clase con los valores correspondientes, si agregamos campos nuevos devemos asegurarnos de tambien agregarlos
		 en la clase ubucada en schemas. 

			Ej de como se va viendo nuestro archivo models.py:

				from app.db.models import Base
				from sqlalchemy import Column, Integer, String, Boolean, DateTime
				from datetime import datetime

				class User(Base): 
				    __tablename__= 'User'
				    id = Column(Integer, primary_key=True, autoincrement=True)
				    nombre = Column(String)
				    apellido = Column(String)
				    direccion = Column(String)
				    telefono = Column(Integer)
				    correo = Column(String)
				    creacion = Column(DateTime, default=datetime.now, onupdate=datetime.now)
				    estado = Column(Boolean)


		-Lo que vamos a hacer ahora es crear nuestras tablas, para ello nos vamos a nuestro archivo main.py, y nos vamos a traer con 
		    -from app.db.database import Base, engine -		
		-DEspues de ello vamos a crear las tablas con una funcion 


			
			ej:

				from fastapi import FastAPI
				import uvicorn
				from app.db.database import Base, engine
				from app.routers import user


				def create_tables():
				    Base.metadata.create_all(bind=engine)

				create_tables()



				create_tables()    

				app = FastAPI()
				app.include_router(user.router)


				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True) 

		-Luego vamos a ir a database.py y vamos a hacer una funcion que lo que hace es devolvernos como tal la session de la base de datos 
		-Esta funcion lo que hace es devolvernos la session de la base de datos, y le dice que despues de todo el proceso que tenga que hacer cierre la 
		 base de datos 	
			ej:

				def get_db():
				    db = SessionLocal()
				    try:
				        yield db   
				    finally:   
				        db.close()


		-Despues de ello vamos a irnos a user.py y vamos a crear una query, que ya la teniamos creada que es para obtener todos los usuarios, pero lo que 
 		 vamos a hacer es editarla. Por que ahora no tenemos que consultar mas lo que esta en la lista usuarios si no lo que esta en la base de datos 
 		
 		-Lo que vamos a hacer es traernos esa funcion que nos devuelve la base de datos 

 			ejemplo:

 				from fastapi import APIRouter, Depends
				from app.schemas import User, User_id
				from app.db.database import get_db
				from sqlalchemy.orm import Session	

		-Ahora en nuestra ruta que nos devuelv todos los usuarios lo que nosotros vamos a decirle 	
		-Esta ruta @router.get('/')  va a recibir siempre algo por defecto que va a ser la - base de datos-
		 			def obtener_usuarios():
		 pero esa base de datos va a ser igual a la session, tambine devemos decirle el tipo de coneccion que nosotros vamos a hacer, como le decimos eso,
		 que esata session va a depender de lo que usted este devolviendo con get_db, como el get_db lo que hace es devolver un onbjeto de tipo sessionmaker.	

			ej:
				@router.get('/')
				def obtener_usuarios(db:Session = Depends(get_db)):

		-Depsues de ello lo que vamos a hacer es realizar una consulta pero para ello devemos traernos el modelo de usuario - from app.db import models -

		-Cosulta para ver la tabla en la base de datos - select * from "User" -  
	
		

		'Creación del modelo venta'

			-Ademas de crear uun modelo de ventas de un usuario o varios, tambien vamos a crearles contraseñas al usuario.


			-Lo que vamos a hacer inicialmente es ir a la archivo models.py y agregaremos a nuestro esquema un -username- que funcionaracomo nombre del 
			 usuario y un -password-

			 	ej:

			 		from app.db.database import Base
					from sqlalchemy import Column, Integer, String, Boolean, DateTime
					from datetime import datetime

					class User(Base): 
					    __tablename__= 'usuario'
					    id = Column(Integer, primary_key=True, autoincrement=True)
					    username = Column(String)
					    password =  Column(String)
					    nombre = Column(String)
					    apellido = Column(String)
					    direccion = Column(String)
					    telefono = Column(Integer)
					    correo = Column(String)
					    creacion = Column(DateTime, default=datetime.now, onupdate=datetime.now)
					    estado = Column(Boolean)

			-Como nosotros hemos hecho ahora un cambio en el modelo, lo que tendriamos que hacer es eliminar la tabla de la base de datos, por que aun
			 no hemos activado la migracios pues ahora toca borrarla.	


			-Ahora lo que devemos hacer es crear el modelo ese que es ventas, y nos importamos la ForeignKey
				
				ej:
					from sqlalchemy.schema import ForeignKey


					class Venta(Base):
					    __tablename__= 'venta'
					    id = Column(Integer, primary_key=True, autoincrement=True)
					    usuario_id = Column(Integer, ForeignKey('usuario.id', ondelete="CASCADE"))
					    venta = Column(Integer)
					    ventas_productos = Column(Integer)

			-Ahora lo que vamos a hacer es entrerelacionar nuestras tablas de usuario y ventas 

				ej:

					from app.db.database import Base
					from sqlalchemy import Column, Integer, String, Boolean, DateTime
					from datetime import datetime

											-----------------------------------------------------
					from sqlalchemy.schema import ForeignKey
					from sqlalchemy.orm import relationship
											-----------------------------------------------------

					class User(Base): 
					    __tablename__= 'usuario'
					    id = Column(Integer, primary_key=True, autoincrement=True)

					    					-----------------------------------------------------
					    username = Column(String)
					    password =  Column(String)
					    					----------------------------------------------------

					    nombre = Column(String)
					    apellido = Column(String)
					    direccion = Column(String)
					    telefono = Column(Integer)
					    correo = Column(String)
					    creacion = Column(DateTime, default=datetime.now, onupdate=datetime.now)
					    estado = Column(Boolean)

					    					-----------------------------------------------------
					    venta = relationship('Venta', backref='usuario', cascade='delete,marge') #aqui establemos la relacion entre las tablas 
					    					-----------------------------------------------------


					    					-----------------------------------------------------
					class Venta(Base):
					    __tablename__= 'venta'
					    id = Column(Integer, primary_key=True, autoincrement=True)
					    usuario_id = Column(Integer, ForeignKey('usuario.id', ondelete="CASCADE"))
					    venta = Column(Integer)
					    ventas_productos = Column(Integer)
					    					-----------------------------------------------------



	"Modificando api crear usuario"
		
		-Lo que vamos a hacer es insertar dato a nuestra tabla de base de datos, entonces vamos a modificarel enpoint en nuestro archivo -user.py-
		-Y tambien vamos a modificar los modelos en models.py y vamos a hacer que el estado de nuestro usuario sea por defecto False, tambien devemos tener
		 en cuenta que ell campo de correo deve ser un campo unic , po rlo tambien tambien vamos a modificar eso.
		-Tambien le vamos a agregar el -username- y el -password- por que posteriormente nos vamos a logear   

			Ej:

				from app.db.database import Base
				from sqlalchemy import Column, Integer, String, Boolean, DateTime
				from datetime import datetime

				from sqlalchemy.schema import ForeignKey
				from sqlalchemy.orm import relationship


				class User(Base): 
				    __tablename__= 'usuario'
				    id = Column(Integer, primary_key=True, autoincrement=True)

				    					-------------------------------------------------------
				    username = Column(String, unique=True)
				    password =  Column(String)
				    					-------------------------------------------------------

				    nombre = Column(String)
				    apellido = Column(String)
				    direccion = Column(String)
				    telefono = Column(Integer)
				    correo = Column(String, unique=True)
				    creacion = Column(DateTime, default=datetime.now, onupdate=datetime.now)

				    					-------------------------------------------------------
				    estado = Column(Boolean, default=False)
				    					-------------------------------------------------------

				    venta = relationship('Venta', backref='usuario', cascade='delete,merge')

				class Venta(Base):
				    __tablename__= 'venta'
				    id = Column(Integer, primary_key=True, autoincrement=True)
				    usuario_id = Column(Integer, ForeignKey('usuario.id', ondelete="CASCADE"))
				    venta = Column(Integer)
				    ventas_productos = Column(Integer)



		-Lo que tenemos que tener en cuenta tambien que al modificar los models tambien devemos agregar las modificaciones en los schemas.py
		-El id del schemas lo podemos eliminar ya que en models hicimos que el id sea autoincrement, vamoa a agregarle al username y el password

			ej:
				from pydantic import BaseModel
				from typing import Optional
				from datetime import datetime

				# User Model
				class User(BaseModel):
						-------------------------------------------
				    username = str
				    password = str
				    	-------------------------------------------

				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    correo:str
				    creacion:datetime=datetime.now()

				class User_id(BaseModel):
				    id:int   


		-Ahora lo que vamos a hacer es modificar el enpoint para inertar un usuario
			
			ej:

				@router.post('/cerar_usuario')
				def crear_usuario(user:User, ------- db:Session = Depends(get_db) ------------):
				    usuario = dict(user)
				    # usuarios.append(usuario)

				    """
				    class User(BaseModel):
				    username = str
				    password = str
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    correo:str
				    creacion:datetime=datetime.now()
				    """
				    		--------------------------------------------------------------------------------
				    nuevo_usuario = models.User(
				        username = usuario["username"],
				        password = usuario["password"],
				        nombre = usuario["nombre"],
				        apellido = usuario["apellido"],
				        direccion = usuario["direccion"],
				        telefono = usuario["telefono"],
				        correo = usuario["correo"],
				    )
				    		--------------------------------------------------------------------------------

				    return {'Respuesta: Usuario creado exitosamente!!'}

		-Ahora lo que devemos hacer es añiadirlo como tal y despues devemos hacer  un respectivo commit 
			
			ej:

				@router.post('/cerar_usuario')
				def crear_usuario(user:User, db:Session = Depends(get_db)):
				    usuario = dict(user)
				    # usuarios.append(usuario)

				    """
				    class User(BaseModel):
				    username = str
				    password = str
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    correo:str
				    creacion:datetime=datetime.now()
				    """

				    nuevo_usuario = models.User(
				        username = usuario["username"],
				        password = usuario["password"],
				        nombre = usuario["nombre"],
				        apellido = usuario["apellido"],
				        direccion = usuario["direccion"],
				        telefono = usuario["telefono"],
				        correo = usuario["correo"],
				    )

				    			-------------------------------------------------------------------
				    db.add(nuevo_usuario)
				    db.commit()
				    db.refresh(nuevo_usuario)
				    			-------------------------------------------------------------------

				    return {'Respuesta: Usuario creado exitosamente!!'}



	'Modificando api para obtener usuario y implementacion de response_model'


		-Lo que vamos a hacer ahora es  modificar el enpoint de otener un usuario utilizando el id, que llega directamente como query parametro.

		-Lo deberiamos hacer aqui es realizar una consulta mediante el orm que ya tenemos de sqlalchemy.
		
		-Entoncesvamos a el archivo de user.py y buscamos en enpoint, y lo que vamos a hacer es es realizar la coneccion con -db:Session = Depends(get_db)-
		 agregandolo a los parametros de nuestro enpoint.
		-Despues de ello lo que nsotros tenermos que hacer es agregar una variable con el nombre -usuario- darle el valor - db.query(models.User)-
		 tenemos que hacer un query al modelo User teniendo en cuanta que anteriomente ya habiamos importado el modulo models, despus del query le colocamos
		  - .felter(models.User.id  == user_id) por loq ue estaremos filtrando y obteniendo del models de user id segun el user_id que ingrese el usuario,
		  y le vamos a colocar - . first() - para que me devuelva el primero. 

		  ej:
			@router.post('/')
			def obtener_usuario_por_id_2(user_id:int, db:Session = Depends(get_db)):
			        usuario = db.query(models.User).filter(models.User.id == user_id)


		-Luego de ello tenemos que validar en el caso que no haya encontrado ninguno 

			ej:
				@router.post('/')
				def obtener_usuario_por_id_2(user_id:int, db:Session = Depends(get_db)):
				    usuario = db.query(models.User).filter(models.User.id == user_id).first()
				    if not usuario:
				        return{'Usuario: no encontrado'}
				    return usuario

		-Ahora solo queremos devolver algunos datos especificos. Con ello tambien podemos definir un schema en donde solo definamos los datos que queremos 
		 que se devuelvan

		-En la ruta como tal cuando nosotros la estamos declarando esto recibe un parametro que se llama - response_model= - , pero este response_model
		 va a ser un schema entonces por lo tanto devemos crear el esquema. 
		-Vamos a nuestro archivo schemas.py y creamos una clase que va a ser ese esquemas

			ej:

				class showUser(BaseModel):
				   username: str 
				   nombre:str
				   apellido:str
				   correo:str

		-Lo otro que devemos hacer es importar esta nueva clase que acabamos de crear 
			
			ej:

				from app.schemas import User, User_id, showUser

		-Luego se lo colocamos al enpoint

			ej:

				@router.post('/{user_id}', response_model= showUser)
				def obtener_usuario_por_id_2(user_id:int, db:Session = Depends(get_db)):
				    usuario = db.query(models.User).filter(models.User.id == user_id).first()
				    if not usuario:
				        return{'Usuario: no encontrado'}
				    return usuario
		
		-Devemos tenemos que hacer enfasis en este punto a que orm va a hacer referencia 		        


			Ej de como se ve nuestro archivo user.py:
			
				from fastapi import APIRouter, Depends
				from app.schemas import User, User_id, showUser
				from app.db.database import get_db
				from sqlalchemy.orm import Session
				from app.db import models

				router = APIRouter(prefix="/user",
				                   tags=["users"])
				usuarios = []


				@router.get('/ruta1')
				def ruta1():
				    return {'Hola mundo :)'}

				@router.get('/')
				def obtener_usuarios(db:Session = Depends(get_db)):
				    data = db.query(models.User).all
				    print(data)
				    return usuarios

				@router.post('/cerar_usuario')
				def crear_usuario(user:User, db:Session = Depends(get_db)):
				    usuario = dict(user)
				    # usuarios.append(usuario)
				    nuevo_usuario = models.User(
				        username = usuario["username"],
				        password = usuario["password"],
				        nombre = usuario["nombre"],
				        apellido = usuario["apellido"],
				        direccion = usuario["direccion"],
				        telefono = usuario["telefono"],
				        correo = usuario["correo"]
				    )
				    db.add(nuevo_usuario)
				    db.commit()
				    db.refresh(nuevo_usuario)
				    return {'Respuesta: Usuario creado exitosamente!!'}

				# @router.post('/{user_id}')
				# def obtener_usuario_por_id(user_id:int):
				#     for user in usuarios:
				#         print (user['id'])
				#         if user['id'] == user_id.id:
				#             return {'Usuario ': user}
				#         return{'Usuario: no encontrado'}
				    

				@router.post('/{user_id}', response_model= showUser)
				def obtener_usuario_por_id_2(user_id:int, db:Session = Depends(get_db)):
				    usuario = db.query(models.User).filter(models.User.id == user_id).first()
				    if not usuario:
				        return{'Usuario: no encontrado'}
				    return usuario


				@router.delete('/{user_id}')
				def eliminar_usuario(user_id:int):
				    for index, user in enumerate(usuarios):
				        if user['id'] == user_id:
				            usuarios.pop(index) 
				            return{'Respuesta: El usuario a sido eliminado correctamente'}
				    else:    
				        return{'El usuario no se ha encontrado'}


				@router.put('/{user_id}')
				def actualizar_usuario(user_id:int, updateUser:User):
				    for index, user in enumerate(usuarios):
				        if user['id'] == user_id:
				            usuarios[index]['id'] = dict(updateUser)['id']
				            usuarios[index]['nombre'] = dict(updateUser)['nombre']
				            usuarios[index]['apellido'] = dict(updateUser)['apellido']
				            usuarios[index]['direccion'] = dict(updateUser)['direccion']
				            usuarios[index]['telefono'] = dict(updateUser)['telefono']
				            return{'Respuesta: El usuario ha sido modificado correctamente'}
				    else:
				        return{'El usuario no se ha encontrado'}


	-Ahora vamos a modificar en enpoint que que cuando queramos obtener todos los datos que tengamos, solo nos devuelva algunos datos determinados.

	-En este caso vamos a obtener una lista de todos los usuarios, por lo tanto vamos a importar de - typing a list - y luego vamos a aplicar
	 a nuestra ruta en los parametros que queremos que nuestro - response_model = list(showUser) -

	 	ej:
	 		from typing import List

	 		@router.get('/', response_model= List[showUser])
			def obtener_usuarios(db:Session = Depends(get_db)):
			    data = db.query(models.User).all()
			    return data			        

    

    'Modificando api eliminar usuario'


    	-Lo que vamos a hacer ahora va a ser modificaar el enpoint para poder eliminar, nos vamos a dirigir al archivo user.py y vamos a buscar el 
    	 enpoint.

    	-Para eliminar tambien tenemos que filtrar para saber que usuario queremos eliminar, 
    	     - usuario = db.query(models.User).filter(models.User.id == user_id) - 
    	-Otra cosa que devemos traernos a los parametros es la base de datos -  db:Session = Depends(get_db) -     
 		
 		-Tambien devemos hacer una condicion por si no se cumple -  if not usuario:
       																	 return{'Usuario: no encontrado'}-

       	-Despues de ello nosotros podemos colocar - usuario.delete(synchronize_session=False) -
       	-Luego devemos hacerle el commit - db.commit()-
       	-Y por ultimo retornamos un mensaje de exito 


       		ejemplo:

			@router.delete('/{user_id}')
				def eliminar_usuario(user_id:int, db:Session = Depends(get_db)):
				    usuario = db.query(models.User).filter(models.User.id == user_id)

				    if not usuario.first():
				        return{'Usuario: no encontrado'}
				    
				    usuario.delete(synchronize_session=False)
				    db.commit()		
				    return{'Respuesta: El usuario a sido eliminado correctamente'}

		
	'implementación del metodo patch'
		

		-Lo que vamos a hacer ahora es implementar el metodo PATCH, ya que este metodo nos brinda la facilidad de poder actualizar-modificar valores 
		 espesificamente, el metodo PUT deviamos modificar todos los campos para que se realice la solicitud correctamente .

		-Lo que vamos a hacer primeramente es obtener el usuario que esta llegando a travez de los parametros 
		         - usuario = db.query(models.User).filter(models.User.id == user_id)-
		-Despues de ello tambien vamos a hacer una codicion por si no se encuentra el usuario  -if not usuario.first():
        																							return{'Usuario: no encontrado'}-
        -Tambien devemos traernos la base de datos a los parametros -, db:Session = Depends(get_db)-
        
        -Y ahora tenemos que implementar devemos colocar - usuario.update()- le vamos a hacer update de lo que estaba llegando desde el body de la 
         posision

        -Tambien vamos a crear  un nuevo schema en el archivo schemas.py que se llame -UpdateUser-

        	ej de como se veria esta clase nueva 

        		class UpdateUser(BaseModel):
				    username:str = None
				    password:str = None
				    nombre:str = None
				    apellido:str = None
				    direccion:str = None
				    telefono:int = None
				    correo:str = None
				    creacion:datetime == None    

		-Luego de esto devemos importarnos esta clase a user.py - from app.schemas import User, User_id, showUser, UpdateUser -
		-Y ahora en el modelo en los parametro de pasamos de donde viene los datos.

			ej:

				def actualizar_usuario(user_id:int, updateUser:UpdateUser, db:Session = Depends(get_db)):

		

		-Luego vamos a crear la logica para poder hacer las momdificaciones 

			Ej 1:

				@router.patch('/{user_id}')
				def actualizar_usuario(user_id:int, updateUser:UpdateUser, db:Session = Depends(get_db)):
				    usuario = db.query(models.User).filter(models.User.id == user_id)
				    if not usuario.first():
				        return{'Usuario: no encontrado'}

				    usuario.update(updateUser.dict(exclude_unset=True))
				    
				    db.commit()
				    return{'Respuesta: El usuario ha sido modificado correctamente'}
				    																						         
 		    
			
			Ej 2:

				@router.patch('/{user_id}')
				def actualizar_usuario(user_id:int, updateUser:UpdateUser, db:Session = Depends(get_db)):
				    usuario = db.query(models.User).filter(models.User.id == user_id)
				    if not usuario.first():
				        return{'Usuario: no encontrado'}
								     
				    nuevo_valor = {}   

				    for i, e in dict(updateUser).items():
				    	if e != None:
				   			nuevo_valor[i] = e
				        
				    usuario.update(nuevo_valor)
				    db.commit()
				    return{'Respuesta: El usuario ha sido modificado correctamente'}


	
	'Migracion de la estructura que interactua con la base de datos a carpeta llamada -repository'

		-Lo que vamos a hacer aqui es migrar toda la estructura que interactua con la base de datos a otra carpeta y en esa otra carpeta vamos a
		 crear funciones colaterales a las rutas en nuetsro archivo user.py 

		-Dentro de la carpeta repository vamos a crear un archivo que se llame -user.py-

		-El primero que migraremos es el de crear usuario, tambien devemos llevarnos a session, osea importar session en -user.py de repository-

		-Tambien devemos importarnos en -user.py de routers- a -from app.repository import user- que seria el archivo de repository. 

		-Tambien devemos importar en la carpeta repository - from app.db import models - 

		- En la ruta de crear usuario modificamos el user del parametro por usuario y dentro de la funcion de la ruta devemos llamar a la fuuncion que
		 acabamos de importar.


			ejemplo del user.py routers:

			-Asi es como quedo la ruta en user.py\routers

				@router.post('/crear_usuario')
				def crear_usuario(usuario:User, db:Session = Depends(get_db)):
				    user.crear_usuario(usuario, db)
				 
				    return {'Respuesta: Usuario creado exitosamente!!'} 		

			
			ejemplo de user.py repository:

			-Asi es como quedo en primer lugar con la migracion en user.py\repository

				from sqlalchemy.orm import Session
				from app.db import models

				def crear_usuario(usuario ,db:Session):
				    usuario = dict(usuario)
				    nuevo_usuario = models.User(
				    username = usuario["username"],
				    password = usuario["password"],
				    nombre = usuario["nombre"],
				    apellido = usuario["apellido"],
				    direccion = usuario["direccion"],
				    telefono = usuario["telefono"],
				    correo = usuario["correo"]
				)
				    db.add(nuevo_usuario)
				    db.commit()
				    db.refresh(nuevo_usuario)	  


			ejemplo del user.py routers:

			-Asi es como quedo la ruta en user.py\routers
			
				@router.post('/{user_id}', response_model= showUser)
				def obtener_usuario_por_id_2(user_id:int, db:Session = Depends(get_db)):
				    usuario = user.obetener_usuario_por_id(user_id, db)
				    return usuario	


			ejemplo de user.py repository:

			-Asi es como quedo en primer lugar con la migracion en user.py\repository	
			
				def obetener_usuario_por_id(user_id, db:Session):
				    usuario = db.query(models.User).filter(models.User.id == user_id).first()
				    if not usuario:
				        return{'Usuario: no encontrado'} 
				    return usuario 



			ejemplo del user.py routers:

			-Asi es como quedo la ruta en user.py\routers

				@router.delete('/{user_id}')
				def eliminar_usuario(user_id:int, db:Session = Depends(get_db)):
				    respuesta = user.eliminar_usuario(user_id, db)
				    
				    return respuesta


		

			ejemplo del user.py routers:

			-Asi es como quedo la ruta en user.py\routers

				@router.get('/', response_model = List[showUser])
				def obtener_usuarios(db:Session = Depends(get_db)):
				    data = user.obetener_usuario(db)
				    return data		   



			ejemplo de user.py repository:

			-Asi es como quedo en primer lugar con la migracion en user.py\repository	
		
				def obetener_usuario(db:Session):
			    data = db.query(models.User).all()
			    return data





			ejemplo del user.py routers:

			-Asi es como quedo la ruta en user.py\routers

			    @router.patch('/{user_id}')
				def actualizar_usuario(user_id:int, updateUser:UpdateUser, db:Session = Depends(get_db)):
				    respuesta = user.actualizar_usuario(user_id, updateUser, db)
				    return respuesta
   



	        ejemplo de user.py repository:

			-Asi es como quedo en primer lugar con la migracion en user.py\repository	

			def actualizar_usuario(user_id, updateUser, db:Session):
			    usuario = db.query(models.User).filter(models.User.id == user_id)
			    if not usuario.first():
			        return{'Usuario: no encontrado'}

			    # usuario.update(updateUser.dict(exclude_unset=True))
			    nuevo_valor = {}   
			    for i, e in dict(updateUser).items():
			        if e != None:
			            nuevo_valor[i] = e
			        
			    usuario.update(nuevo_valor)
			    db.commit()
			    return{'Respuesta: El usuario ha sido modificado correctamente'}


	'Creación de variables de entorno'	
	

		-Las variables de entorno se pueden usar para almacenar cualquier tipo de valor, pero son especialmente útiles para almacenar valores 
		 que se consideran secretos, como las claves de API o las contraseñas.

		La definición exacta de las variables de entorno en FastAPI es la siguiente:

		Una variable de entorno en FastAPI es una variable que se almacena en el sistema operativo y que se puede utilizar en toda la aplicación.

		Las variables de entorno se pueden usar para:

		Almacenar configuraciones de la aplicación, como la dirección del servidor de base de datos o la dirección del servidor de correo electrónico.
		Almacenar secretos, como las claves de API o las contraseñas.
		Controlar el comportamiento de la aplicación, como la activación de funciones o la configuración de límites.


		-Lo que vamos a hacer ahora es crear un archivo nuevo en la carpeta app que se llame - .env - 

		-Luego a ello vamos a agregar e intalar en el archivo requirments - python-dotenv -, posterior a ello vamos a proceder a instalarlo en comando 
		 -pip install -r requeriments.txt  -


		-Luego vamos a pasar a configirar nuestro archivo .env, mas especisifico crear nuestras conecciones a la base de datos 
		
		-Vamos a comenzar por ebtener el nombre de nuestra base de datos, y se lo vamos a asignar a una variable.
		-Aqui todas las variables las vamos a escribir en mayuscula 

			ej:

				POSTGRES_DB = fastapi-database


		-Luego vamos a obtener el usuario de la base de datos.

			ej:

				POSTGRES_USER = postgres

		-Luego vamos a obtener ek password de la base de datos.	

			ej:

				POSTGRES_PASSWORD = Neyen1995


		-Luego el server
			
			ej:

				POSTGRES_SERVER = localhost

		-Luego el puerto
			
			ej:
				POSTGRES_PORT = 5432



		-Listo hasta aqui ya hemos creado nuestras variables de entorno, lo que vamos a hacer ahora es crear una carpeta en el mismo lugar de app,
		 no dentro de app si o en la misma picioosion, que se llame - core - y destro de esa carpeta vamos a creaer un archivo - __init__.py - 
		 y vamos a crear otro archivo que se llame - config.py-

		-Luego dentro de nuestro archivo config.py dentro de core vamos a importar a os - import os - que es para navegar en nuestro sistema operativo
		 y tambien vamos a importar - from dotenv import load_dotenv - , y vamos a importarnos a - from pathlib import path -  

		 	ej:
				import os
				from dotenv import load_dotenv 
				from pathlib import Path


		-Despues de ello lo que vamos a hacer es ubicar donde esta nuestro - .env - por lo tanto con esto - env_path = Path('.') / '.env' - le estamos
		 deciendo que valla una carpeta atras y que ubique a nuestro .env. 

		 	ej:

		 		import os
				from dotenv import load_dotenv 
				from pathlib import Path

				env_path = Path('.') / '.env'

		-Luego de ello devemos cargarlo con - load_dotenv(dotenv_paht=env_path).


			ej:

				import os
				from dotenv import load_dotenv 
				from pathlib import Path

				env_path = Path('.') / '.env'
				load_dotenv(dotenv_path=env_path)

		-Ahora con esto si yo quiero obtener por ejemplo una de los valores de las variables de entorno que habiamos creado en .env	solo tenemos que decirles
		 print(os.getenv('POSTGRES_DB')) y  para ver el resultado devemos ejecutarlo de la consola con python .\core\config.py


		-Ahora dentro del archivo config.py vamos a crear una clase que se llame - Settings: - y dentro de esta clase vamos a darle un nombre a nuestro 
		 proyecto y una vercion, luego de eso vamos a comenzar a obtener los valores de las variables de entorno. 

		 	ej:
		 		import os
				from dotenv import load_dotenv 
				from pathlib import Path

				env_path = Path('.') / '.env'
				load_dotenv(dotenv_path=env_path)
				print(os.getenv('POSTGRES_DB'))	

							--------------------------------------------------------------------------------
				class Settings:
				    PROJECT_NAME: str = 'PROYECTO-FAST-API'
				    PROJECT_VERSION: str = '1.0'
				    POSTGRES_DB: str = os.getenv('POSTGRES_DB')
				    POSTGRES_USER: str = os.getenv('POSTGRES_USER')
				    POSTGRES_PASSWORD: str = os.getenv('POSTGRES_PASSWORD')
				    POSTGRES_SERVER: str = os.getenv('POSTGRES_SERVER')
				    POSTGRES_PORT: str = os.getenv('POSTGRES_PORT')
							---------------------------------------------------------------------------------
							
		-Ahora tenemos que hacer la url de nuestra base de datos, por lo que vamos a seguir como una guia la url que habiamos creado anteriormente y vamos 
		 a reemplazar los valores con variables

		-Y luego vamos a crear una varible mas que sea - settings = Settings() - , para que ya podamos acceder a la url .

		 	ej:

		 		class Settings:
				    PROJECT_NAME: str = 'PROYECTO-FAST-API'
				    PROJECT_VERSION: str = '1.0'
				    POSTGRES_DB: str = os.getenv('POSTGRES_DB')
				    POSTGRES_USER: str = os.getenv('POSTGRES_USER')
				    POSTGRES_PASSWORD: str = os.getenv('POSTGRES_PASSWORD')
				    POSTGRES_SERVER: str = os.getenv('POSTGRES_SERVER')
				    POSTGRES_PORT: str = os.getenv('POSTGRES_PORT')

				    						-----------------------------------------------------------------------------
				    # SQLALCHEMY_DATABASE_URL = "postgresql://postgres:Neyen1995@localhost:5432/fastapi-database"

				    DATABASE_URL = f'postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_SERVER}:{POSTGRES_PORT}/{POSTGRES_DB}'  


			    settings = Settings()
			    						-----------------------------------------------------------------------------	


		-Ahora lo que tenemos que hacer es irnos hasta database.py e importarnos a la variable settings que acamos de crear
		-Y tambien devemos borrar -SQLALCHEMY_DATABASE_URL = "postgresql://postgres:Neyen1995@localhost:5432/fastapi-database"- el valor y ahora devemos
		 pasarle el valor de - settings.DATABASE_URL -



			ej en el archivo database.py :

				from sqlalchemy import create_engine
				from sqlalchemy.ext.declarative import declarative_base
				from sqlalchemy.orm import sessionmaker

										----------------------------------------------------------------------------
				from core.config import settings

				# SQLALCHEMY_DATABASE_URL = "postgresql://postgres:Neyen1995@localhost:5432/fastapi-database"
				SQLALCHEMY_DATABASE_URL = settings.DATABASE_URL
										---------------------------------------------------------------------------

				engine = create_engine(SQLALCHEMY_DATABASE_URL)
				SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False )
				Base = declarative_base()

				def get_db():
				    db = SessionLocal()
				    try:
				        yield db   
				    finally:   
				        db.close()  


	'Migración a los modelos con Alembic'
	
		-Alembic: es una libreria que nos permite realizar migraciones a nuestro modelos de la base de datos

		-En simples palabras, Alembic es una herramienta que te ayuda a gestionar tu base de datos. 
		 Te permite crear nuevas tablas, columnas o índices, o modificar los datos existentes, de forma segura y consistente.
		 De otro forma para poder actualizar modificar etc nuestra base de datos deveriamos hacerlo desde la misma base de datos o actualizar en 	
		 nuestro codigo ir a la base de datos borrar las columnas y vovler a correr nuestra aplicacion por lo tanto no es factible. 


		-Lo que vamos a hacer es ir a nuestro requeriments.txt y agregamos Alembic, y posterior a eso lo instalaremos 
		
		-Lo que vamos a hacer es crear una carpeta nueva con el nombre de - mrigations - la vamos a crear en la carpeta raiz que en este casi seria 
		 - FASTAPI - 

		-Para crearla vamos a poner en comando -  alembic init migrations-
		

		-Luego vamos a buscar en alembic.init la variable llamada --sqlalchemy.url = driver://user:pass@localhost/dbname -- , y lo que vamos a hacer con ella 
		 vamos a eliminar el valor que tiene, por que posteriormente lo vamos a rellenar ya que no se puede hacer nada en ese tipo de archivos.

		-Entonces lo que  vamos a hacer ahora es ir a -env.py- y vamos a editar a - sqlalchemy.url = - 
		-En nuestro env.py vamos a encontrar una variable llamada -config- que es para acceder a los valores del -.init- 
		-Entonces le vamos a colocar ----config.set_main_option()---- y en el primer parametro vamos a colocar el nombre de lo que nosotros queremos 
		 editar, y luego le colocaremos el valor que nosotros elijamos.

		-Y el valor nosotros actualmente lo tenemos en DATABASE_URL en la carpeta config.py de la carpeta core. Por lo tanto tendriamos que impprtar 
		 el en la carpeta actual --- from core.config import settings ----
   	         										    


   	         ej de como se veria el archivo:

   	         	from core.config import settings

   	         	config = context.config
				config.set_main_option('sqlalchemy.url', settings.DATABASE_URL)


		-La otra configuracion que nosotros necesitariamos es que reconosca los modelos que nosotros necesitamos editar, necesitamos que reconosca los modelos 
		 que tenemos en la carpeta -db- y dentro del archivo models.py, para poder despues realizar las migraciones 
		-Por lo tanto nos vamos a nuestro archivo - env.py- que esta en la carpeta migrations y lo que tenemos que comentar es -- target_metadata = None --
		 y descomentamos --- from myapp import mymodel
							 target_metadata = mymodel.Base.metadata --- estos dos que estan arriba del anterior-, entonces devemos acceder a los modelos 
		desde - from app.db.models import Base - , el target_metadata lo que tenemos que hacer es colocar esto -- target_metadata = Base.metadata--


			ej:

				from app.db.models import Base
				target_metadata = Base.metadata
				# target_metadata = None

		-Y esto se va a encargar de reconoser los modelos y si tenen algun cambio esos modelos por favor realice sus respectovas migraciones 
		


		-Desppues de ello lo otro que deveriamos hacer es que nos vamos al main.py y vamos a comentar # def create_tables():
																								      		#Base.metadata.create_all(bind=engine)
																								      #create_tables()




		
		-Lo que tendriamos que hacer para en fin realizar las migraciones es ejecutar dos comandos 
		----- alembic revision --autogenerate -m "Crear modelos" -----	

		-Para poder crear las tablas usuario y ventas directamente colocamos en comando - alembic upgrade heads- cuendo ejecutemos esto esto utomaticamente 
		 lo que va a hacer es ir a la base de datos y generar las tablas 



		-Para poder eliminar una columna , solo devemos dirigirnos a los modelos en el archivo -models.py- y simple mente borrar la columna desea, 
		 luego volver a correro los comandos  ----- alembic revision --autogenerate -m "Crear modelos" -----	y  - alembic upgrade heads-

		-Si quiero agregarle otra columna, lo unico'Excepciones HTTP y status codes'
		 que tengo que hacer es agregar la columna que quiero en models y vovler a ejecutar los comando






	'Excepciones HTTP y status codes'

		-Lo que vamos a hacer ahora es devolver un status de nuestra solicitud

		-En términos simples, los códigos de estado HTTP son mensajes que envía un servidor a un cliente para indicar el resultado de una solicitud HTTP.

		 Los códigos de estado HTTP se componen de tres dígitos. El primer dígito indica la categoría del código. 
		 Los códigos de estado HTTP se clasifican en cinco categorías:

		 2xx: éxito
		 3xx: redirección
		 4xx: error del cliente
		 5xx: error del servidor
		 Los dos dígitos siguientes proporcionan más información sobre el código. Por ejemplo, 
		 el código 200 indica que la solicitud se ha realizado correctamente. 
		 El código 404 indica que el recurso solicitado no se encontró.


		-Vamos a empzr a hacer validaciones primero con obtener usuarios, esto lo hacemos en user.py que esta dentro de la carpeta routers.

		- Luego vamos a importar tambien a -status-

			ejemplo:

				from fastapi import APIRouter, Depends, status

		-Lo que vamos a hacer es decirle que status code va a devovler, eso lo podemos hacer directamente en los parametros

			ej:

				@router.get('/', response_model = List[showUser], status_code=status.HTTP_200_OK)
				def obtener_usuarios(db:Session = Depends(get_db)):
				    data = user.obetener_usuario(db)
				    return data

		-En la ruta de crear usuario nosotros tenemos que devolver 201

			ejemplo:

				@router.post('/crear_usuario',status_code=status.HTTP_201_CREATED	)
				def crear_usuario(usuario:User, db:Session = Depends(get_db)):
				    user.crear_usuario(usuario, db)
				 
				    return {'Respuesta: Usuario creado exitosamente!!'}	


		
		-Ahora lo que deveriamos hacer es manejar los errores y eso lo devemos hacer en el archivo -user.py- de la carpeta repository,
		 por lo tanto vamso a manejar ahora el error de -crear usuarios- 

		-Ahora vamos a utilizar try, y except. por lo tanto al hacer esto y si cremos un usuario lo hacemos erroneamente va a entrar al except y ahi tendriamos
		 que devolver el error. 
		-En el código que has proporcionado, la instrucción except Exception as e: es como el árbitro del juego. 
		 Si algo sale mal, el árbitro dirá "¡Error!" y mostrará el mensaje "Error papi". 

		 	ejemplo:

		 		from fastapi import HTTPException, status

		 		def crear_usuario(usuario ,db:Session):
			    try:
			        usuario = dict(usuario)
			        nuevo_usuario = models.User(
			        username = usuario["username"],
			        password = usuario["password"],
			        nombre = usuario["nombre"],
			        apellido = usuario["apellido"],
			        direccion = usuario["direccion"],
			        telefono = usuario["telefono"],
			        correo = usuario["correo"]
			    )
			        db.add(nuevo_usuario)
			        db.commit()
			        db.refresh(nuevo_usuario)
			    except Exception as e:
			        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f'Error creando usuario{e}')


		-Ahora vamos a modificar obtener usuarios por id .
		-Por lo tanto si no encuentra un usuario lanza el 404 no found 

			ej:

				def obetener_usuario_por_id(user_id, db:Session):
				    usuario = db.query(models.User).filter(models.User.id == user_id).first()
				    if not usuario:
				        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail= f'No existe el usuario con el id {user_id}')
				    return usuario   



		-Ahora vamos con el de eliminar usuario 

			ej:

				def eliminar_usuario(user_id, db:Session):
				    usuario = db.query(models.User).filter(models.User.id == user_id)

				    if not usuario.first():
				        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f'No existe el usuario con el id{user_id}')
				    usuario.delete(synchronize_session=False)
				    db.commit()	
				    return{'Respuesta: El usuario a sido eliminado correctamente'}


		-Ahora vamos a actualizar el usuario 

			ej:

				def actualizar_usuario(user_id, updateUser, db:Session):
				    usuario = db.query(models.User).filter(models.User.id == user_id)
				    if not usuario.first():
				        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, 
				                            detail=f'El usuario con el id {user_id} no ha sido encontrado')

				    # usuario.update(updateUser.dict(exclude_unset=True))
				    nuevo_valor = {}   
				    for i, e in dict(updateUser).items():
				        if e != None:
				            nuevo_valor[i] = e
				        
				    usuario.update(nuevo_valor)
				    db.commit()
				    return{'Respuesta: El usuario ha sido modificado correctamente'}		    


	
	'Encriptar contraseña'

		-En este momento como tenemos la contraseña denuestra app esta en un tipo varchar, pero no esta encriptada. Estamos hablando de las contraseñas 
		 de cada usuario cuando se crea uno. 

		-Lo que tenemos que hacer enn primera instancia es instalar a - passlib[bcrypt]- . pero primero devemos agregarlo a nuestro archivo 
		 requeriments.txt - pip install -r  requeriments.txt -

		-Una ves que la allammos instalados devemos importarnos un de esta libreria a -from passlib.context import CryptContext- 
		en la carpeta repository y en nuestro archivo user.py

		-Luego devemos agregar esta linea de codigo - pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto") -, que estamos declarando un onbjeto
		 para crear la contraseña 


		-Luego directamente nos vamos donde creamos el usuario y obtenemos la contraseña en la carpeta repository y en el archivo user.py 
		 y lo que vamos a hacer es dentro de try vamos a crear una variable - password_hash= pwd_context.hash(usuario["password"]) - y le pasamos
		 la contraseña que estamos recibiiendo, y en el objeto donde estamos creando el usuario le pasamos la variable que acabamos de crear

		 	ej:
			 	from passlib.context import CryptContext
				pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

		 		def crear_usuario(usuario ,db:Session):
				    try:
				    	usuario = dict(usuario)

				    	------------------------------------------------------------
				        password_hash= pwd_context.hash(usuario["password"])
				        ------------------------------------------------------------

				        nuevo_usuario = models.User(
					        username = usuario["username"],
					        ------------------------------------------------------------
					        password = password_hash,
					        ------------------------------------------------------------

					        nombre = usuario["nombre"],
					        apellido = usuario["apellido"],
					        direccion = usuario["direccion"],
					        telefono = usuario["telefono"],
					        correo = usuario["correo"]
				    )
				        db.add(nuevo_usuario)
				        db.commit()
				        db.refresh(nuevo_usuario)
				    except Exception as e:
				        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f'Error creando usuario{e}')



		-Ahora lo que devemos hacer es es desencriptar la contraseña del usuario para que luego el usuario se pueda autenticar 
		-Para ello lo que nsotros vamos a hacer es crear dentro de nuestra carpeta app un nuevo archivo llamado - hashing.py-

		-Y dentro de ese archivo vamos a crear una clase llamada - class Hash(): - y dentro vamos a crear la funcion que va a ser para primero encrptar 
		 la contraseña, por o tanto lo que habiamos importando antes en repository user.py esto -- 			 	
		 from passlib.context import CryptContext
		 pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")-- devemos trasladarlo a esta nueva carpeta que acavamos de crear.

		 	ej:

		 		from passlib.context import CryptContext
				pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


				class Hash():
				    def hash_password(password):
				        return  pwd_context.hash(password)


		-Y en la carpera repository en el archivo user.py nos vamos a tarer el modulo hashing.py --from app.hashing import Hash--

		

			ej:

				from app.hashing import Hash


				def crear_usuario(usuario ,db:Session):

					---------------------------------------------------------------
				    usuario = dict(usuario)
				    ---------------------------------------------------------------

				    try:
				        nuevo_usuario = models.User(
				            username = usuario["username"],

				            ------------------------------------------------------
				            password = Hash.hash_password(usuario["password"]),
				            ------------------------------------------------------

				            nombre = usuario["nombre"],
				            apellido = usuario["apellido"],
				            direccion = usuario["direccion"],
				            telefono = usuario["telefono"],
				            correo = usuario["correo"]
				    )
				        db.add(nuevo_usuario)
				        db.commit()
				        db.refresh(nuevo_usuario)
				    except Exception as e:
				        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f'Error creando usuario {e}')
				         

		
	'Verificación de contraseña'
		

		-Lo que vamos a hacer ahora es implementar un login y verificar la contraseña, que esto tambien vendria a ser parte de descriptar la contraseña 
		 para que el usuario pueda hacer login. 

		-Para ello vamos a crear un nuevo archivo dentro de la carpeta routers que se llame - auth.py - y como lo vamos a crearcomo una ruta devemos 
		 importar algunas cosas, y vamos a ponerle como nombre en el prefix de router - '/login' - y los tags - ['Login'] 	

		 	ej:

		 		from fastapi import APIRouter, Depends, status
				from app.db.database import get_db
				from sqlalchemy.orm import Session
				from typing import List

				router = APIRouter(prefix="/login",
				                   tags=["Login"])  


		-Despues de ello lo que vamos a hacer es crear una ruta

			ej:

				from fastapi import APIRouter, Depends, status
				from app.db.database import get_db
				from sqlalchemy.orm import Session
				from typing import List

				router = APIRouter(prefix="/login",
				                   tags=["Login"])

				@router.post('/', status_code=status.HTTP_200_OK)
				def login(db:Session = Depends(get_db)):
				    return {'respuesta: login correcto'}     

		-Ahora como estamos creando un router tenemos que añadirlo a nuestra aplicacion 
		-Nos vamos a nuestro archivo main.py, e importamos a nuestro nuevo archivo auth.py  de - from app.routers import user, auth	- 
		 y vamos a incluir a a nuestra aplicacion ese nuevo router que es de autenticacion 

		 	ej:

		 		from fastapi import FastAPI
				import uvicorn
				#from app.db.database import Base, engine
				from app.routers import user, auth


				# def create_tables():
				#     Base.metadata.create_all(bind=engine)

				# create_tables()
				    
				app = FastAPI()
				app.include_router(user.router)
				app.include_router(auth.router)


				if __name__ == '__main__':
				    uvicorn.run('main:app', port=8000, reload=True)	    
				        



	    -Ahora nosotros para realizar un login devemos nosotros tenemos que enviarle un body.
	    -Entonces no vamos para a crear un nuevo schema en schemas.py que se llame - class Login():

	    	ej:

	    		class Login(BaseModel):
				    username : str
				    password : str 

		-Ahora vamos a nuestro archivo de auth.py y nos vamos a trer el schemas que acavamos de crear - from app.schemas import Login-
		 y se lo vamos a pasar directamente como parametro a la ruta

		 	ej:

		 		from fastapi import APIRouter, Depends, status
				from app.db.database import get_db
				from sqlalchemy.orm import Session
				from typing import List

				-------------------------------------------------------------------
				from app.schemas import Login
				-------------------------------------------------------------------

				router = APIRouter(prefix="/login",
				                   tags=["Login"])

				@router.post('/', status_code=status.HTTP_200_OK)
				def login(login:Login, db:Session = Depends(get_db)):
				    return {'respuesta: login correcto'} 	    
										 

		-Ahora vamos a realzar nuestro primer filtro y es si es usuario existe
		-Para ello vamos a la carpeta repository y vamos a crear un nuevo archivo llamado - auth.py - y dentro de este archivo nos vamos a importar 
			-	from sqlalchemy.orm import Session
				from app.db import models
				from fastapi import HTTPException, status	- 
		-Y lo primero que vamos a hacer en auth.py es crear una funcion que se llame - auth_user - esta funcion va a recibir un usuario y tambien la base de
		 datos como parametros.
		-Despues de ello lo que deveriamos hacer es filtrar el usuario por lo tanto crearemos una variable lamada user dentro de la funcion que va 
		 a ser igual a - db.query(models.User).filter(models.User.username == usuario['username']), antes de ello devemos convertir el usuario en un dict.

		-Recibimos la imformacion de usuario directamente del schemas de Login por que es lo que nosotros le estamos enviando desde el body. 

			ej:

				from sqlalchemy.orm import Session
				from app.db import models
				from fastapi import HTTPException, status

				def auth_user(usuario, db:Session):
				    usuario = dict(usuario)
				    user = db.query(models.User).filter(models.User.username == usuario['username'])
						

		-Luego de eso devemos validar si el usuario no existe 

			ej:

				from sqlalchemy.orm import Session
				from app.db import models
				from fastapi import HTTPException, status

				def auth_user(usuario, db:Session):
				    usuario = dict(usuario)
				    user = db.query(models.User).filter(models.User.username == usuario['username']).first()
				    if not user:
				        raise HTTPException(
				            status_code=status.HTTP_404_NOT_FOUND,
				            detail=f'no existe el usuario {usuario["username"]}'
				        )	

		-Luego vamos a auth.py de la carpeta routers y vamos a importar - from app.repository import auth-
		-Y luego devemos desde dentro de la funcion de de la ruta acceder a el modulo que acavamos de importar y llamar a la funcion de auth_user y pasarle
		 los argumnetos correspondiente 

		 	ej:
			 	from fastapi import APIRouter, Depends, status
				from app.db.database import get_db
				from sqlalchemy.orm import Session
				from typing import List
				from app.schemas import Login
				from app.repository import auth

				router = APIRouter(prefix="/login",
				                   tags=["Login"])

				@router.post('/', status_code=status.HTTP_200_OK)
				def login(usuario:Login, db:Session = Depends(get_db)):
				    auth.auth_user(usuario, db)
				    return {'respuesta: login correcto'}

		
		-Ahora lo que deveriamos hacer es verificar la contraseña, para ello vamos dirigirnos al archivo hashing.py dentro de la carpeta routers
		 y vamos a crear un nuevo metodo dentro de la clase Hash. 

		-Esta funcion deve recibir el password directamente del query que hemos realizado anteriormente, osea la contraseña que nosotros hemos guardado 
		 en la base de datos y el otro parametro es la contraseña que ingresa el usuario mediante la api, que estariamos enviando directamente del body 


		 	ej de como se va viendo:

		 		from passlib.context import CryptContext
				pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


				class Hash():
				    def hash_password(password):
				        return  pwd_context.hash(password)

				   	----------------------------------------------------------- 
				    def verify_password(plain_password, hashed_password):
				        return pwd_context.verify(plain_password, hashed_password)
				    -----------------------------------------------------------
		
		-Y ahora en el archivo auth.py de repository dentro de la funcion auth_user devemos hacer la validacion de la contraseña, para ello devemos importarnos
		 da hashing Hash - from app.hashing import Hash - 

		-Vamos a imprimir primero el resultado de dicha verify_password con un print
			ej:

				from sqlalchemy.orm import Session
				from app.db import models
				from fastapi import HTTPException, status
				from app.hashing import Hash 

				def auth_user(usuario, db:Session):
				    usuario = dict(usuario)
				    user = db.query(models.User).filter(models.User.username == usuario['username']).first()
				    if not user:
				        raise HTTPException(
				            status_code=status.HTTP_404_NOT_FOUND,
				            detail=f'no existe el usuario {usuario["username"]}'
				        )
				        -------------------------------------------------------------------------------
				    print('Esta es la contraseña', Hash.verify_password(usuario["password"], user.password)) 
 		        

		-Entonces ahora cuando todo este correcto vamos a verify, si la contraseña ingresada no es True, entonces es False. 

			ej:
				from sqlalchemy.orm import Session
				from app.db import models
				from fastapi import HTTPException, status
				from app.hashing import Hash 

				def auth_user(usuario, db:Session):
				    usuario = dict(usuario)
				    user = db.query(models.User).filter(models.User.username == usuario['username']).first()
				    if not user:
				        raise HTTPException(
				            status_code=status.HTTP_404_NOT_FOUND,
				            detail=f'no existe el usuario {usuario["username"]}'
				        )
				    print('Esta es la contraseña', Hash.verify_password(usuario["password"], user.password))

				    --------------------------------------------------------------------------------------
				    if not Hash.verify_password(usuario["password"], user.password):
				        raise HTTPException(
				        status_code=status.HTTP_404_NOT_FOUND,
				        detail=f'Contraseña incorrecta')
				    ---------------------------------------------------------------------------------------  


	'Generacion de JWT'
		
		-En FastAPI, un JWT es un token de acceso que se utiliza para autenticar a los usuarios de una API. JWT significa "JSON Web Token" 
		y es un estándar abierto para representar información de forma segura entre dos partes.

		Un JWT consta de tres partes:

		Cabecera: contiene información sobre el token, como el tipo de token y el algoritmo de firma utilizado.
		Cargas útiles: contiene la información del usuario, como el nombre de usuario, el ID de usuario y los roles del usuario.
		Firma: se utiliza para verificar la autenticidad del token.
		En FastAPI, los JWT se pueden utilizar para autenticar a los usuarios de dos maneras:

		Autenticación basada en JWT: en este caso, el usuario envía el token JWT en la solicitud de autorización. 
		El token se verifica y, si es válido, el usuario se autentica.
		Autenticación basada en token de refresco: en este caso, el usuario envía el token JWT en la solicitud de autorización. 
		El token se verifica y, si es válido, se genera un nuevo token de refresco. El usuario puede utilizar el token de refresco para 
		obtener un nuevo token JWT en el futuro			      


		-Para generar un jwt devemos instalar -- python-jose -- entonces lo que vamos a hacer es  ir a  requeriments.txt y aniadirlo a las descargas 

			ej de la carpeta de requeriments.txt:

				fastapi
				uvicorn
				psycopg2
				SQLALchemy
				python-dotenv
				alembic
				passlib[bcrypt]
				bcrypt==3.2.0
				python-jose[cryptography]
				python-multipart


		-Entonces ahora si no entra en ninguno de los if de la funcion auth_user en el archivo auth.py dentro de la carpeta repository, eso significa que la 
		 contraseña y el usuario se iniciaron bien por lo tanto nosotros alli devemos generar el jwt .	

		-Pero primero antes de ello vamos a crear un nuevo archivo dentro de la carpeta app que se llame - token.py - y dentro de ese archivo vamos a 
		 hacer una importacion de la libreria que acavamos de instalar - from jose import JWTError, jwt - y tambien nos vamos a importar a 
		 		-from datetime import datetime, timedelta-

		-Y lo proximo que vamos a agregar van a ser la SECRET_KEY , ALGORITHM, ACCESS_TOKEN_EXPIRE_MINUTES, que a esto lo podemos encontrar en la 
		 documentacion de fastapi. 	

		 	ej de como se ve el archivo hasta el momento:

		 		from jose import JWTError, jwt
		 		from datetime import datetime, timedelta


				SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
				ALGORITHM = "HS256"
				ACCESS_TOKEN_EXPIRE_MINUTES = 30


		-Luego nos vamos a schemas.py y vamos a añadir un esquemas mas.

			ej:

				from pydantic import BaseModel
				from typing import Optional
				from datetime import datetime

				# User Model
				class User(BaseModel):
				    username:str
				    password:str
				    nombre:str
				    apellido:str
				    direccion:Optional[str]
				    telefono:int
				    correo:str
				    creacion:datetime=datetime.now()

				class UpdateUser(BaseModel):
				    username: str = None
				    password: str = None
				    nombre: str = None
				    apellido: str = None
				    direccion: str = None
				    telefono: int = None
				    correo: str = None
				    creacion: datetime = None

				 
				class showUser(BaseModel):
				   username:str 
				   nombre:str
				   apellido:str
				   correo:str
				   class Config():
				       orm_mode = True

				class Login(BaseModel):
				    username : str
				    password : str

				    	-------------------------------------------------------------------------------
				class Token(BaseModel):
				    access_token: str
				    token_type: str


				class TokenData(BaseModel):
    				username: Union[str, None] = None              		  	
				    	------------------------------------------------------------------------------

		-Luego vamos a el archivo token.py y vamos a crear una funcion que va a recibir como parametro un dic - data:dict - en el caso que nosotros 	
		 querramos encriptar datos directamente en el jwt.	

		 	ejemplo de la funcion :

		 		from jose import JWTError, jwt
				from datetime import datetime, timedelta

				SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
				ALGORITHM = "HS256"
				ACCESS_TOKEN_EXPIRE_MINUTES = 30

				def create_access_token(data: dict):
				    to_encode = data.copy()
				    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
				    to_encode.update({"exp": expire})
				    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
				    return encoded_jwt  

			-Lo que haceesta funcion es que recibe la imformacion atraves del parametro data y luego le agregauna nueva llave y le pasa la variable 	
			 que hemos creado con el tiempo de expiracion del token luego generamos el jwt y lo retornamos .

		-Posterior a ello nos vamos a auth.py de la carpeta repository y vamos a añadir a la funcion  auth_user el llamado a la funcion que acavamos de crear	
		 en token.py, para ello devemos traernos la funcion - from app.token import create_access_token - y luego en la funcion de declaramos una variable
		 que sea igual a la funcion de create_access_token y le pasamos los parametros correspondiente 

		 	ej:

		 		from sqlalchemy.orm import Session
				from app.db import models
				from fastapi import HTTPException, status
				from app.hashing import Hash 
				from app.token import create_access_token

				def auth_user(usuario, db:Session):
				    usuario = dict(usuario)
				    user = db.query(models.User).filter(models.User.username == usuario['username']).first()
				    if not user:
				        raise HTTPException(
				            status_code=status.HTTP_404_NOT_FOUND,
				            detail=f'no existe el usuario {usuario["username"]}'
				        )
				    print('Esta es la contraseña', Hash.verify_password(usuario["password"], user.password))

				    if not Hash.verify_password(usuario["password"], user.password):
				        raise HTTPException(
				        status_code=status.HTTP_404_NOT_FOUND,
				        detail=f'Contraseña incorrecta') 
				        ----------------------------------------------------------------------------
				    access_token = create_access_token(
				        data={'sub': user.username}
				    )
				    return{'access token': access_token, 'token_type':'bearer'}       	
				    	----------------------------------------------------------------------------

		-Por lo tanto ahora nuestra ruta en auth.py en la carpeta routers va a devolver algo .	
		
			ej:

				from fastapi import APIRouter, Depends, status
				from app.db.database import get_db
				from sqlalchemy.orm import Session
				from app.schemas import Login
				from app.repository import auth

				router = APIRouter(prefix="/login",
				                   tags=["Login"])

				@router.post('/', status_code=status.HTTP_200_OK)
				def login(usuario:Login, db:Session = Depends(get_db)):

					-------------------------------------------------------------
				    auth_token = auth.auth_user(usuario, db)
				    return auth_token	    	
					-------------------------------------------------------------


	'Protección de rutas'

		-Lo primero que devemos hacer es crearun nuevo archivo dentro de la carpeta app que se llame -oauth.py-, y dentro lo primero que vamos a hacer es 
		 importar Depends - from fastapi import Depends - , tambien vamos a importar  a
		  - from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm -
		
		-Luego vamos a crear una variable con el nombre de - oauth2_scheme = OAuth2PasswordBearer(tokenUrl='login') -
		 el tokenUrl significa la url donde nosotros vamos a validar directamente el token , por lo tanto en este caso lo que devemos colocarle es Login

		-Y luego una funcion que se va a encargar de validar el token.

			ej de la archivo oauth.py:

				from fastapi import Depends
				from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm

				oauth2_scheme = OAuth2PasswordBearer(tokenUrl='login')

				def get_current_user(token: str = Depends(oauth2_scheme)):
				    pass				


		-Lo otro que tenemos que hacer seria es añadir las credenciales por si hay un error, por lo tanto devemos importar - HTTPException - y -status-,
		 y vamos a implementar la logica al la funcion get_current_user. Tambien devemos importarnos -from typing import Annotated- 
 	

		 	ej:

		 		from fastapi import Depends, HTTPException, status
				from fastapi.security import OAuth2PasswordBearer   
				from app.token import verify_token
				from typing import Annotated

				oauth2_scheme = OAuth2PasswordBearer(tokenUrl='login')

				def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
				    credentials_exception = HTTPException(
				        status_code=status.HTTP_401_UNAUTHORIZED,
				        detail='could not validate credentials',
				        headers={'WWW-Authenticate': 'Bearer'}
				    )
				    return verify_token(token, credentials_exception)

		-Ahora lo que vamos a hacer es la verificacion de los token, vamos a dirigirnos al archivo token.py y vamos a crear una nueva funcion llamada 
		   -verify_token- y le  vamos a pasar como parametro el token que va a ser un str. Esto lo que hace es decodificar el token le pasa la SECRET_KEY
		 y tambien le pasa el algoritmo, despues lo que hace es obtener la llave sub que habiamos creado anteriormente, si el username es none significa 
		 que la llave no existe por lo tanto el usuario no esta autenticado y va a devolver credentials_exception por lo tanto devemos añadir credentials_exception
		 como parametro y tenemos que enviarla como argumento donde estamos llamando la funcion verify_token. Despues devemos crerar una variable  
		 y como valor devemos traernos al tokenData que es el schema que habiamos creado por lo tanto devemos importar ese tokenData, 


		 	ej:
		 		from jose import JWTError, jwt
				from datetime import datetime, timedelta
				from app.schemas import TokenData

				SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
				ALGORITHM = "HS256"
				ACCESS_TOKEN_EXPIRE_MINUTES = 30

				def create_access_token(data: dict):
				    to_encode = data.copy()
				    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
				    to_encode.update({"exp": expire})
				    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
				    return encoded_jwt

				    	---------------------------------------------------------------------------------
				def verify_token(token:str, credentials_exception):
				    try:
				        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
				        username: str = payload.get("sub")
				        if username is None:
				            raise credentials_exception
				        token_data = TokenData(username=username)
				        # return token_data
				    except JWTError:
				        return credentials_exception

				        ---------------------------------------------------------------------------------



		-Ahora en el archivo oauth.py lo que vamos  hacer es traernos la funcion verify_token que cabamos de crear 
		     - from app.token import verify_token -      
		 y lo que vamos a hacer es llamar a la funcion verify_token dentro de la funcion get_current_user y le vamos a pasar como argumento 
		 el token que estamos recibiendo en la funcion get_current_user

		-Por untimo retornamos cuando verificamos el token 

		 	ej:

		 		from fastapi import Depends, HTTPException, status
				from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
				from app.token import verify_token

				oauth2_scheme = OAuth2PasswordBearer(tokenUrl='login')

				def get_current_user(token: str = Depends(oauth2_scheme)):
				    credentials_exception = HTTPException(
				        status_code=status.HTTP_401_UNAUTHORIZED,
				        detail='could not validate credentials',
				        headers={'WWW.Authenticate': 'Bearer'}
				    )
				     return verify_token(token, credentials_exception)     
   			   	      

		-Ahora por ejemplo si queremos proteger alguna ruta devemos aplicar la logica para ello. Por lo tanto devemos ir a la ruta que deseamos proteger
		 y devemos pasarle como parametro.

		-Nos dirigimos al archivo user.py de la carpeta routers, y aplicamos como parametro aquellas rutas que queremos proteger, 
			- current_user: User = Depends(get_current_user)- , por lo tamto devemos importarnos a get_current_user - from app.oauth import get_current_user-

			ej de una ruta:

				from app.oauth import get_current_user


				@router.get('/', response_model = List[showUser], status_code=status.HTTP_200_OK)
				def obtener_usuarios(db:Session = Depends(get_db), ----current_user: User = Depends(get_current_user)----):
				    data = user.obetener_usuario(db)
				    return data	 		    


		-Y por ultimo en el archivo auth.py de la carpeta routers devemos umportarnos - from fastapi.security import OAuth2PasswordRequestForm-
		 que eso nos va a traer la autenticacion que ingrese el usuario y devemos pasarcelo como valor del parametro de la funcion login, tambien devemos
		 instalar a - python-multipart - por lo tanto devemos añadirlo al archivo requirments.txt

		 	ej 		:

		 		from fastapi import APIRouter, Depends, status
				from app.db.database import get_db
				from sqlalchemy.orm import Session
				from app.schemas import Login
				from app.repository import auth
				from fastapi.security import OAuth2PasswordRequestForm


				router = APIRouter(prefix="/login",
				                   tags=["Login"])

				@router.post('/', status_code=status.HTTP_200_OK)
				def login(usuario:OAuth2PasswordRequestForm = Depends(), db:Session = Depends(get_db)):
				    auth_token = auth.auth_user(usuario, db)
				    return auth_token


		-Ahora el ultimo cambio seria, nosotros antes le estavamos pasando en la carpeta repository en el archivo auth.py estavamos pasando los usuarios 
		 como modelos, ahora tenemos que hacer es borrar la variable usuario que tranformavamos a dict, y a donde estavamos haciendo los llamados 
		 a propiedades de usuario solo devemos hacerlo con un punto (.) ya que estariamos haciendo referencia a un atribujo deun objeto.

		 	ej del archivo completo:

		 		from sqlalchemy.orm import Session
				from app.db import models
				from fastapi import HTTPException, status
				from app.hashing import Hash 
				from app.token import create_access_token

				def auth_user(usuario, db:Session):
				    user = db.query(models.User).filter(models.User.username == usuario.username).first()
				    if not user:
				        raise HTTPException(
				            status_code=status.HTTP_404_NOT_FOUND,
				            detail=f'no existe el usuario {usuario.username}'
				        )
				    print('Esta es la contraseña', Hash.verify_password(usuario.password, user.password))

				    if not Hash.verify_password(usuario.password, user.password):
				        raise HTTPException(
				        status_code=status.HTTP_404_NOT_FOUND,
				        detail=f'Contraseña incorrecta') 
				    access_token = create_access_token(
				        data={'sub': usuario.username}
				    )
				    return{'access token': access_token, 'token_type':'bearer'}		    
    


    'Implementacion de test'

    	'Obtener el token mediante postman (form-data)'

    		-Ver video numero 26.



    	'Implementacion de test crear usuario'

    		-Lo primero que vamos a hacer es crear una carpeta que se llame -test- en el proyecto raiz (donde se encuenta nuesta archivo main.py)
    		-Luego dentro de la carpeta vamos a crear un nuevo archivo que se llame - test_api.py -	
    		-Despues de ello nosotros vamos a ejecutar los test con -pytest- que lo agregamos directamente al archivo requirments.py y lo instalamos, 
    		 tambien devemos agregara requests y httpx.
 


    		-Pytest lo que hace es irce directamente a la carpera, cuando nosotros ejecutamos pytest directamente en consola, esto lo que hace es buscar 
    		 en la carpeta actual (una carpeta que se llama test) y despues de entrar a la carpeta que se llama test encuentra todos los archivos que 
    		 comiences por test y depsues de ello lo que hacees que ejecutar toda las dunciones que comiencen directamente por test 


    		-Lo siguiente que vamos a hacer es traernos - from fastapi.testclient import TestClient -  TestClient lo que va a hacer principalmente es 
    		 hacer una peticion de tipo request a la api y la api nos tiene que devolver un si o un no 

    		-Despues de ello vamos a declarar una variable llamada -cliente - que va a ser un objeto de testclient ye pasamos nuestra app. Por lo tanto 
    		 devemos importarnos de main a nuestra app -from main import app- , luego de ello, si ajecutamos pytest no va a dar un error por que 
    		 esta buscand la ruta en la carpeta actual, por lo tanto devemos importarnos tambien a - import sys- y a - import os- para poder navegar por
    		 los directorios, y luego implementamos -sys.path.append(os.path.join(os.path.dirname(__file__), '../'))- que esto lo que va a hacer 
    		 es devolverce una carpeta atras y buscar el archivo main.py, devemos de asergurarnos de que la importacion de main se haga despues de implementar
    		 este codigo que vuelve una carpeta atras.  

    		 	ej:

    		 		from fastapi.testclient import TestClient
					import sys
					import os

					sys.path.append(os.path.join(os.path.dirname(__file__), '../'))
					from main import app

					cliente= TestClient(app)


			-Despues de ello lo que vamos a hacer es ejecutar nuestro primer test de prueva, creando una funcion que se llame - def test_crear_usuario-

			-Ahora como sabemos el al enpoion para crear usuario le teniamos que pasar un body con los valores que ingrese el usuario, lo que vamos  a hacer
			 es implementar ese body en nuestra funcion y vamos a crear un un objeto llamado -usuario-.

			 	ej:

			 		from fastapi.testclient import TestClient
					import sys
					import os

					sys.path.append(os.path.join(os.path.dirname(__file__), '../'))
					from main import app

					cliente= TestClient(app)

						-----------------------------------------------------------------------
					def test_crear_usuario():
					    usuario = {
					        "username": "string",
					        "password": "string",
					        "nombre": "string",
					        "apellido": "string",
					        "direccion": "string",
					        "telefono": 0,
					        "correo": "string",
					        "creacion": "2023-12-28T09:12:03.423679"
					    }	

  						-----------------------------------------------------------------------

  			-Ahora nosotros tenemos que hacer un peticion de tipo POST, por es eso lo que recibe la api, y si todo sale bien despues de hacer la peticion
  			 nos deveria devolver un resultado de 201  por que es el que habiamos pasado anteriormente como status en la creacion de api

  			-Lo que devemos hacer es declarar una variable - response- que va a ser igual al cliente que habiamos declaro antes punto post y directamente 
  			 le colocamos la ruta, tambien devemos pasarle el usuario en json paraque pase usuario en fromato json a nuestra api.	

  			-Devemos recordr que para que se imprima en consola todos estos metodos devemos ejecutar a - pytest -s -

  			-Lo que me va a imprimir en consola va a ser el status code 201 si salio todo bien, pero s queremos imprimir todos los metodos que tiene
  			 ese  objeto directamente le podemos poner - print(response, dir(response))-  si queremos devolver el status code - print(response.status_code),
  			 ademas de devolvernos el status_code tambien nos tiene que devolver un json con el mensaje que le allamos pasado cuando creamos nuestra api
  			 para cuando se cree un usuario correctamente, para obtener ese json devemos  poner - print(response.json) - 

  			 	ej: 

  			 		from fastapi.testclient import TestClient
					import sys
					import os

					sys.path.append(os.path.join(os.path.dirname(__file__), '../'))
					from main import app

					cliente= TestClient(app)

					def test_crear_usuario():
					    usuario = {
					        "username": "string",
					        "password": "string",
					        "nombre": "string",
					        "apellido": "string",
					        "direccion": "string",
					        "telefono": 0,
					        "correo": "string",
					        "creacion": "2023-12-28T09:12:03.423679"
					    }
					    -------------------------------------------------------
   						response = cliente.post('/user/crear_usuario', json=usuario)
   						print(response)
					    -------------------------------------------------------

        
        -Assert: En programación, una aseveración es una declaración que verifica una condición y, si la condición no se cumple, genera una excepción. 
        Las aserciones se utilizan para verificar la validez de los datos o el estado del programa. Pueden ser útiles para detectar errores temprano, 
        durante la depuración, o para garantizar que el programa se comporte de la manera esperada

        -Si nosotros colocamos un Assert antes del print para  verificar si el status_code es == a 201, si no lo es me va a devolver un status_code dependiendo del error 
         que se ocacione. ej de lo que nos devolveria si falla :E       assert 409 == 201E        +  where 409 = <Response [409 Conflict]>.status_code
         test\test_api.py:22: AssertionError
        	
        	ej:

        		from fastapi.testclient import TestClient
				import sys
				import os

				sys.path.append(os.path.join(os.path.dirname(__file__), '../'))
				from main import app

				cliente= TestClient(app)

				def test_crear_usuario():
				    usuario = {
				        "username": "nn",
				        "password": "nn",
				        "nombre": "string",
				        "apellido": "string",
				        "direccion": "string",
				        "telefono": 0,
				        "correo": "neyen@gmail.com",
				        "creacion": "2023-12-28T09:12:03.423679"
				    }
				    response = cliente.post('/user/crear_usuario', json=usuario)
				    -----------------------------------------------------------------------------
				    assert response.status_code == 201
				    print(response.json())
				    -----------------------------------------------------------------------------
				    pass


	'Creación de base de datos solo para pruebas y se elimina al terminar los test'			    


		-Crearemoa una base de  datos local con sqlite para pruebas.

		-Sabiendo que con - os.path.dirname(__file__) -  obtenemos la direecion actual de donde nos encontramos, lo primero que vamos a hacer 
		 es colocarle un nombre a la base de datos, esto lo vamos a hacer en nuestro archivo test_api.py  en la carpeta test, y el nombre que le vamos 
		 a dar a nuestra base de datos de prubas es - db_path - es va a ser igual a - os.path.join(os.path.dirname(__file__), 'test_db'), lo que hace esto
		 es darle un nombre a nuestra base de datos que la va a ir a buscar dentro de la carpeta test dentro del archivo test_db.

		-Para crear nuestra instancia de sqlite, lo que tenemos que haces es crear una variable llamada -  db_uri - que va a ser igual a 
		 'sqlite:///{}'.format(db_path), lo que queremos hacer con esta linea es decirle que nuestra coneccion de sqlite esta en la ruta absoluta que hemos 
		 indicado con el db_path. 

		 	ej:

		 		db_path = os.path.join(os.path.dirname(__file__), 'test_db')
				db_uri = 'sqlite:///{}'.format(db_path)

		-Despues de ello lo que teemos que hacer es traernos - from sqlalchemy import create_engine - que es con esto que nosotros vamos a crear 
		 nuestro primer usuario, tambien vamos a traernos -from sqlalchemy.orm import sessionmaker- 

		-Ahora lo que tenemos que hacer es definir la url de la base de datos que generalmente le comolocamos como SQLALCHEMY_DATABASE_URL, entonces
		 ceamos una variable que se llame SQLALCHEMY_DATABASE_UR que sea igual a db_uri. 

		-Lo que hacemos ahora es crear nuestro engine que lo vamos a llamar - engine_test - que va a ser igual a 
				- engine_test = create_engine(db_uri, connect_args='check_same_thread': False)- y asi es como creamos el engine

		-Despues de ello devemos declarar un objeto de sessionmaker 
			- testingSessionLocal = sessionmaker(bind=engine_test, autocommit=False, autoflush=False)- 

		-Despues de ello para crear todas las tablas lo que dvemos hacer es traer nuestro Base de los models por que tiene que interpretar que tablas 
		 debe crearn entonces lo traemos de - from app.db.models import Base - , despues de traernos a Base devemos colocar 
		 	-Base.metadata.create_all(bind=engine_test)- , esto lo que va a hacer es crear todas las tablas de nuestra base de datos

		-Y luego corremos con -pytest -s- en consola, y si todo esta bien automaticamente se nos crea la base de datos con el nombre - test_db - 	 

		 		ej:

		 			from fastapi.testclient import TestClient
					import sys
					import os

					------------------------------------------------------------------------
					from sqlalchemy import create_engine
					from sqlalchemy.orm import sessionmaker
					------------------------------------------------------------------------

					sys.path.append(os.path.join(os.path.dirname(__file__), '../'))

					-------------------------------------------------------------------------
					from app.db.models import Base

					db_path = os.path.join(os.path.dirname(__file__), 'test_db')
					db_uri = 'sqlite:///{}'.format(db_path)
					SQLALCHEMY_DATABASE_URL = db_uri
					engine_test = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={'check_same_thread': False})
					testingSessionLocal = sessionmaker(bind=engine_test, autocommit=False, autoflush=False)
					Base.metadata.create_all(bind=engine_test)
					-------------------------------------------------------------------------

					from main import app

					cliente= TestClient(app)

					def test_crear_usuario():
					    usuario = {
					        "username": "nn",
					        "password": "nn",
					        "nombre": "string",
					        "apellido": "string",
					        "direccion": "string",
					        "telefono": 0,
					        "correo": "neyen@gmail.com",
					        "creacion": "2023-12-28T09:12:03.423679"
					    }
					    response = cliente.post('/user/crear_usuario', json=usuario)
					    assert response.status_code == 201
					    print(response.json())
					    pass


		-Lo que devemos hacer hora, es copiar la ruta de la base de datos haciendo click derecho sobre el archivo y copiar acceso, luego nos vamos a 
		 nuestro dBeaver y vamos a colocar nueva coneccion, colocamos que va a ser de sqlite y pegamos la ruca que habiamos copiado, provamos coneccion 
		 y luego le ponemos un nombre mas leelevante para que entendamos de donde viene esa base de datos y para que por ejemplo - test_db_fastapi- 


		-Ahora lo que tenemos que hacer es insertar un nuevo usuario. Vamos a crear una funcion que se llame - def insertar_usuario_prueba():-
		 que lo que va a hacer es ejecutar una cosulta sql, por lo tanto devemos crear en esta funcion tambien la apertura de la base de datos 
		 y el cierre como tal, por lo tando devemos crear un try y un finally. Tambien devemos importarnos a text - from sqlalchemy import tetx -

		 	ej:

		 		def insertar_usuario_prueba():
				    session = testingSessionLocal()
				    try:
				        statement = text(
				            """
				            INSERT INTO usuario(username, password, nombre, apellido, direccion, telefono, correo)
				            VALUES('pueba', 'prueba123', 'prueba_nombre', 'prueba_apellido', 'prueba_direcc', 1234, 'Neyen@gmail.com')
				            """
				        )
				        session.execute(statement)
				        session.commit()
				    finally:
				        session.close()

		-Resulta y pasa que aasi como esta esta funcion la contraseña me la esta pasando como string, por lo tanto lo que devemos hacer es pasarla a hash

		-Lo que vamos a hacer vamos directamente a hashing.py y vamos a hashear la contrseña, y nosvamos a traer la funcion hash 
			- from app.hashing import Hash- y dentro de la funcion insertar_usuario_prueba declaramos una variable llamada - password_hash-
		y de valor hacemos el llamado a la funcion hash.hash_password('prueba123'), y luego en values directamente le pasamos la variable, asi hasheamos 
		la contraseña

			ej:	

				from fastapi.testclient import TestClient
				import sys
				import os
				from sqlalchemy import create_engine
				from sqlalchemy import text
				from sqlalchemy.orm import sessionmaker
				sys.path.append(os.path.join(os.path.dirname(__file__), '../'))
				from app.db.models import Base

				----------------------------------------------------------------------
				from app.hashing import Hash
				----------------------------------------------------------------------

				db_path = os.path.join(os.path.dirname(__file__), 'test_db')
				db_uri = 'sqlite:///{}'.format(db_path)
				SQLALCHEMY_DATABASE_URL = db_uri
				engine_test = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={'check_same_thread': False})
				testingSessionLocal = sessionmaker(bind=engine_test, autocommit=False, autoflush=False)
				Base.metadata.create_all(bind=engine_test)


				from main import app

				cliente= TestClient(app)

				
				def insertar_usuario_prueba():

				    password_hash = Hash.hash_password('prueba123')
				    statement = text(
				    f"""
				    INSERT INTO usuario(username, password, nombre, apellido, direccion, telefono, correo)
				    VALUES('pueba', '{password_hash}', 'prueba_nombre', 'prueba_apellido', 'prueba_direcc', 1234, 'Neyen@gmail.com')
				    """
				)
				insertar_usuario_prueba()

				def test_crear_usuario():
				    usuario = {
				        "username": "nn",
				        "password": "nn",
				        "nombre": "string",
				        "apellido": "string",
				        "direccion": "string",
				        "telefono": 0,
				        "correo": "neyen@gmail.com",
				        "creacion": "2023-12-28T09:12:03.423679"
				    }
				    # response = cliente.post('/user/crear_usuario', json=usuario)
				    # assert response.status_code == 201
				    # print(response.json())
				    # pass	 

		-Lo tro que deveriamo hacer que es importante es ahacer referecia a la bas de datos de prueba para que podamos trabajar con ella sin interferir en 
		 la base de datos original. Para ello devemos crear la funcion que abra y cierre la coneccion a la base de dato de pruebas, despues de ello devemos 	
		 traernos el get_db que esta en la carpeta db yen el archivo database.py - from app.db.database import get_db-, despues de ello nosotros vamos a 
		 hacerle un override a la base de datos que ya a la base de datos que tenia en la aplicacion guardada y la tenemos que reemplazar con la conexion 
		 que tenemos en sqlite 

		 	ej:
		 		from app.db.database import get_db

		 		def override_get_db():
				    db = testingSessionLocal()
				    try:
				        yield db   
				    finally:   
				        db.close()
				app.dependency_overrides[get_db] = override_get_db



		-Lo otro que deveriamos hacer eliminar la base de datos deprueva para que podamos seguir haciendo pruevas y no nos tire el error que ya tenemos el	
		 usuario o algun parametro de usuario repetido. 

		-Para ello devemos crearuna nueca funcion que se llame - def test_delete_database()- le pasamos el db_path completo que va a ser el mismo que antes 
			-db_path = os.path.join(os.path.dirname(__file__), 'test_db')- y lo que tenemos que hacer ew colocarle -os.remove(db_path)

			ej:

				def test_delete_database():
				    db_path = os.path.join(os.path.dirname(__file__), 'test_db')

				    # Cerrar todas las conexiones o sesiones de la base de datos
				    engine_test.dispose()

				    # Introducir un pequeño retraso antes de intentar eliminar el archivo
				    time.sleep(1)

				    # Intentar eliminar el archivo
				    try:
				        os.remove(db_path)
				        print(f"Archivo de base de datos eliminado: {db_path}")
				    except FileNotFoundError:
				        print(f"El archivo de base de datos no existe: {db_path}")
				    except Exception as e:
				        print(f"Error al eliminar la base de datos: {e}")



		ej de como se ve el archivo :
			
			from fastapi.testclient import TestClient
			import sys
			import os
			from sqlalchemy import create_engine
			from sqlalchemy import text
			from sqlalchemy.orm import sessionmaker
			sys.path.append(os.path.join(os.path.dirname(__file__), '../'))
			from app.db.models import Base
			from app.hashing import Hash
			from app.db.database import get_db
			import time

			db_path = os.path.join(os.path.dirname(__file__), 'test_db')
			db_uri = 'sqlite:///{}'.format(db_path)
			SQLALCHEMY_DATABASE_URL = db_uri
			engine_test = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={'check_same_thread': False})
			testingSessionLocal = sessionmaker(bind=engine_test, autocommit=False, autoflush=False)
			Base.metadata.create_all(bind=engine_test)

			from main import app

			cliente= TestClient(app)

			def override_get_db():
			    db = testingSessionLocal()
			    try:
			        yield db   
			    finally:   
			        db.close()
			app.dependency_overrides[get_db] = override_get_db


			def insertar_usuario_prueba():

			    password_hash = Hash.hash_password('prueba123')
			    statement = text(
			    f"""
			    INSERT INTO usuario(username, password, nombre, apellido, direccion, telefono, correo)
			    VALUES('pueba', '{password_hash}', 'prueba_nombre', 'prueba_apellido', 'prueba_direcc', 1234, 'Neyen@gmail.com')
			    """
			)
			   
			insertar_usuario_prueba()

			def test_crear_usuario():
			    usuario = {
			        "username": "nn",
			        "password": "nn",
			        "nombre": "string",
			        "apellido": "string",
			        "direccion": "string",
			        "telefono": 0,
			        "correo": "neyen@gmail.com",
			        "creacion": "2023-12-28T09:12:03.423679"
			    }
			    response = cliente.post('/user/crear_usuario', json=usuario)
			    assert response.status_code == 201
			    print(response.json())
			    pass

			def test_delete_database():
			    db_path = os.path.join(os.path.dirname(__file__), 'test_db')

			    # Cerrar todas las conexiones o sesiones de la base de datos
			    engine_test.dispose()

			    # Introducir un pequeño retraso antes de intentar eliminar el archivo
			    time.sleep(2)

			    # Intentar eliminar el archivo
			    try:
			        os.remove(db_path)
			        print(f"Archivo de base de datos eliminado: {db_path}")
			    except FileNotFoundError:
			        print(f"El archivo de base de datos no existe: {db_path}")
			    except Exception as e:
			        print(f"Error al eliminar la base de datos: {e}")		    	    
																		

	-'Test crear usuario enviando el JWT'
	

		-Si nosotros queremos hacer las pruevas en la nueva base de datos, pero las rutas en donde nosotros hacemos las peticiones estan 
		 protegidas por un token. 
																											






								          	      	    
																												   							 
																																	            	        	
																											   
																									  		    

																	    
												 		     
								 			    					



					     




									  	
								    









